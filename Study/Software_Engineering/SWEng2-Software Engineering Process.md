# Software Engineering Process

- 대규모 프로젝트 수행시

  - 요구 분석 -> 시스템 설계 -> SW 구조 설계 -> SW 상세 설계 -> UI 설계 -> 프로그래밍 ...

- 소규모(테트리스) 프로젝트 수행시

  - **요구 분석:** 그 중요성은 아무리 강조해도 지나치지 않음

    PC방 주인이 2인용 전투 테트리스 설계를 주문했다고 가정하자

  - **프로젝트 로드맵 설계:** 1인용 흑백 콘솔 테트리스 -> 2인용 컬러 GUI 테트리스

  - **소스 트리 설계:** deterministic 요소 (데이터 모델) 과 non-deterministic 요소 (외부 인터페이스)로 나눠서 설계

  - **데이터 모델 설계:** 시나리오들의 집합화(결과물: 순서도)와 시나리오 연산화(결과물: 객체간 연산 정의) 위주로 구상

  - **데이터 모델 코딩:** 단순 시나리오 -> 시나리오 확장

    - 단순 시나리오 (객체 하나 + 시나리오 하나) -> 확장 시나리오 코딩 (객체 다수 + 시나리오 다수)
    - 데이터 모델의 단순성을 추구해야 함

---

### 테트리스 프로젝트 소스 트리 설계

- 시스템적 측면 (non-deterministic)

  키 입력, 화면 출력, 타이머 구동, 난수 발생 등

- 알고리즘 측면 (dterministic)

  - 블록 출현 후
    - 이동: 좌, 우, 아래, 추락
    - 회전 (90도)
  - 블록 충돌
    - 좌/우 충돌
    - 아래/추락 충돌
    - 회전 충돌
  - 행 삭제
  - 배경 화면 갱신 및 신규 블록 출현

---

### 테트리스 데이터 모델 설계

- 시나리오 연산화: common scenario 고려 (결과물의 객체 연산의 정의)

  - 주요 객체들 구상: 배경, 벽, 쌓인 블록들, 내려오는 블록, ...

  - 객체 추상화: 서로 다른 성격의 객체들도 가능한 한 동일한 클래스로 취급할 수 있도록 클래스를 정의 (예: 배경, 벽, 7가지 블록들 -> 행렬)

    이러한 공격적인 추상화가 시나리오 코딩에 미치는 영향을 추후에 신중히 검토해야 함

  - 객체 단순화: 추상화된 클래스가 너무 복잡한 속성들로 정의되지 않도록 최대한 속성을 단순화 (예: 컬러 블록 -> 흑백 블록)

- 시나리오들 집합화: 모든 시나리오 고려 (결과물: 순서도)

  - 가능한 시나리오들을 순서도 형태로 열거한다.
  - 각 시나리오를 선택하여 가급적이면 동일한 타입의 객체의 연산으로 표현한다.

---

### 테트리스 데이터 모델 코딩

- 단순 시나리오 코딩: Matrix class를 이용함
  - 콘솔 입출력(사용자 인터페이스)은 시스템 측면의 코딩이므로 matrix.py 파일과 분리된 pytet.py 파일로 작성함
  - 난수 발생 또는 키 입력과 같은 non-deterministic 요소는 고정된 값을 갖는다고 가정함.
  - 데이터 모델 설계의 초기 단계부터 콘솔 프린트(print)를 이용하여 모델을 구상, 보정하는 것은 필수적임.
- 확장 시나리오 코딩: Matrix class의 메소드들을 최대한 활용함
  - 추상화된 Matrix 객체들로 모든 시나리오가 해당 객체들의 연산들로 표현 가능한지를 실제로 코딩하면서 검증함 -> 그 결과 만들어진 것이 Matrix 클래스임
    - 단순 시나리오: 객체 하나 + 시나리오 하나
    - 확장 시나리오: 객체 다수 + 시나리오 다수 
  - 데이터 모델의 단순성을 추구해야 함
    - Matrix 객체를 이용하여 배경, 벽, 쌓인 블록, 떨어지는 블록을 모두 표현할 수 있고, 그들 사이의 연산들을 몇 가지로 정의할 수 있어야 함
    - 객체를 반복 사용함으로 인해서 버려지는 객체들이 발생할 수 있으며, 이로인한 메모리 낭비는 데이터 모델 설계 단계에서 코딩의 생산성을 위해서 감수할 수 있음

---

### 코딩 지침들

- 기능 위주의 코딩을 먼저 해라.

  - 기능이 완성될 때까지는 성능 최적화를 걱정하지 마라.

  - 컴퓨터 자원 (메모리, CPU)을 사용함으로써 코딩이 단순해지면 자원을 사용하라.

    참고로, 메모리 자원보다는 CPU 자원이 더 소중하다.

- 불필요한 조건문들을 없애라

  - 조건문이 많아지면 버그들도 많아진다.
  - 경계 조건을 강제하는 조건문들은 sentinel key로 없앨 수 있다.
  - 사전 테스트보다 사후 테스트가 유리한 경우도 있다.
  - if-elif-elif-...-else 구조는 가급적 사용하지 않는다.

- 반복되는 코드 조각을 없애라

  - 가능하면 하나의 함수로 작성하라.

  - 함수 작성시 "출력=동사(입력1, 입력2, ... )" 형태로 정의하라.

  - 함수는 그 로직이 종속되는 파일 안에 코딩하라.

    테트리스 로직을 라이브러리 안에 코딩하지 마라.

---

## Software Engineering Process

## 프로세스 없는 개발

- Code-and-fix
  - 가이드라인이나 프로세스 없는 코딩과 수정의 반복
  - 문제점
    - 요구 분석, 설계 없음 -> 사용자의 요구 수준에 도달 못함, 구조 나빠짐
    - 계획이 없어 작업 목표가 없음 -> 비용과 일정 조절 불가
    - 체계적인 테스트나 품질 보증 활동에 대한 인식 없음 -> 결함 악화
  - 유지보수 비용 증가

---

## 프로세스와 방법론

- 프로세스 (process)
  - 소프트웨어 시스템을 구축하기 위하여 수행되는 작업의 단계
  - 소프트웨어 개발에 대한 기술적, 관리적 이슈를 다루는 작업
  - 일반적으로 개발할 때 해야 할 작업만을 명시
  - 어떤 관계가 있는지 나타내지 않음
- 방법론 (methodology)
  - 프로세스의 각 작업을 어떻게 수행하는지 정의
  - 입력자료, 산출물, 수행 방법을 자세히 제시

---

- Process
  - 특징
    - 단계적인 작업의 틀을 정의한 것
    - 무엇을 하는가에 중점
    - 결과물이 표현에 대하여 언급 없음
    - 각 단계가 다른 방법론으로도 실현가능
  - 사례
    - 폭포수 프로세스
    - 나선형 프로세스
    - 프로토타이핑 프로세스
    - Unified 프로세스
    - 애자일 프로세스
- Methodology
  - 특징
    - 프로세스의 구체적인 구현에 이름
    - 어떻게 하는가에 중점
    - 결과물을 어떻게 표현하는지 표시
    - 각 단계의 절차, 기술, 가이드라인을 제시
  - 사례
    - 구조적 분석, 설계 방법론
    - 객체지향 방법론
    - 컴포넌트
    - 애자일 방법론

---

## 소프트웨어 생명주기

- 소프트웨어 생명주기 (Software Life Cycle)
  - 개발 -> 변경,추가 -> 소멸
  - 집 짓는 과정과 비슷

요구분석->설계->구현->테스팅->유지보수

---

## 프로세스

- 프로세스 (process)
  - 소프트웨어 시스템 구축을 위한 작업의 단계
  - 소프트웨어 개발에 대한 기술적, 관리적 이슈를 다루는 작업
  - 여러 컴포넌트 프로세스로 구성

---

### 프로세스의 종류

- 프로젝트의 중심 프로세스

  - 개발(development) 프로세스

    개발 작업, 품질 보증 작업 등

  - 관리(management) 프로세스

    비용, 품질, 기타 목표를 맞추기 위한 계획, 제어 작업

  - 형상 관리 (configuration management) 프로세스

    변경, 버전 관리

- 기타 프로세스

  - 프로세스 관리 프로세스

---

### 프로세스 정의

- 프로세스 정의 (프로젝트의 목표를 만족시킬 수 있는 잘 정의된 작업)

  - 많은 단계로 나누면 안됨 - 문서나 결과물 증가
  - 진입 조건, 출구 조건, 검증 작업 정의
  - 작업 결과와 검증 조건을 명확히 정의해야 함
    - 해당 단계에 유입된 결함을 찾음 -> 비용 절감
    - 정형화되어 한눈에 보여야 함

- 개발 프로세스의 작업 결과 (work product)

  - 요구 분석서, 설계 문서, 코드, 프로토타입 등
  - 명확하고 검증 가능한 문서 생성

- 프로세스의 시작과 끝 정의

  - 진입조건

    프로세스를 시작하기 위해 만족해야하는 조건

  - 출구조건

    프로세스를 종료하기 위해 결과물이 만족해야하는 조건

  - 진입조건은 그 전 단계의 출구조건과 일치해야 함

- 프로세스 관리를 위한 정보

  프로세스 상태를 관리 프로세스에 제공 -> 프로세스 컨트롤

---

### 좋은 프로세스의 특성

- 좋은 프로세스의 특성
  - 예측 가능성 (predictability)
  - 테스트 가능성과 유지보수 용이성 (testability and maintainability)
  - 변경 용이성 (modifiability)
  - 결함 제거 용이성 (fault recoverability)

---

- 예측 가능성 (predictability)

  >  프로젝트 완성 전에 프로세스의 결과가 얼마나 정확하게 예측될 수 있는가

  - 예측할 수 없는 프로세스는 사용하기 어려움

  - 비용 예측

    - 프로젝트 A가 과거 프로젝트 B와 유사

      -> 예측 가능한 프로세스를 사용하면 유사한 비용 발생

  - 품질 예측

    - 개발 단계중 어떤 오류가 얼마나 나올지 예측
    - 같은 프로세스로 만들어진 과거 제품의 품질로 예측

  - 예측 가능한 프로세스의 오류 분포 예측

    - 과거의 경험을 바탕으로 예측
    - 통계적으로 처리 가능

    예) 과거 프로젝트에 100줄 당 2개의 오류 발견

    현재 프로젝트의 테스팅 과정에서 100줄 당 10개의 오류 발견

    -> 품질 저하 예상

- 테스팅과 유지보수 용이성

  - 개발 비용 < 유지보수 비용

    > 유지보수가 쉬운 프로그램을 만들어야 함

    테스팅 비용이 가장 크다.(실제 코딩보다) -> 테스팅에 충분한 자원을 배정해야 함

- 변경 용이성

  - 변경을 쉽게 다룰 수 있는 프로세스
  - 기술의 발전에 따라 생활 패턴, 업무 방식 등의 변화
  - 수정하기 어려운 프로세스는 적합하지 않음
  - 개발 과정에서의 변경
    - 고객 요구 변경
    - 개발자의 작업 결정 변경

  **변경은 항상 일어남 -> 변경을 쉽게 다룰 수 있어야 함**

- 결함 제거 용이성

  - 일반적으로 '개발의 중심 = 코딩'

    -> 대부분의 오류가 코딩에서 발생한다고 생각

  - 오류는 모든 개발 과정에서 발생할 수 있음

    - 코딩(50%)
    - 설계(30%)
    - 요구분석(20%)

  - 오류 발견과 수정 소요 비용

    - 발견이 지연될수록 비용은 커짐

    ex) 요구 분석에서 오류 발생 후 테스트에서 오류 발견

    -> 설계와 코드 모두 변경 -> 비용 증가

  - 각 단계의 출력을 다음 단계 시작 전에 검증 (품질 보증 작업)

---

## 프로세스 모델

- 프로세스 모델
  - 일반적인 개발 단계를 단순화하여 표현
  - 다양한 접근 방식을 설명
- 대표적인 프로세스 모델
  - 폭포수 모델 (waterfall model)
  - 프로토타이핑 모델 (prototype model)
  - 나선형 모델 (spiral model)
  - 진화적 모델 (incremental model)
  - Unified Process
  - 애자일 프로세스 (agile process)

---

### 폭포수 모델

- 폭포수 모델 (waterfall model)

  - 가장 오래되고 널리 사용된 프로세스 모델 (라이프 사이클 패러다임)

  - 순차적

    - 각 단계가 다음 단계 시작 전에 끝나야 함
    - 각 단계 사이에 중복이나 상호작용이 없음

    **중간 단계 결과물 (deliverable)을 명확히 정의해야 함**

- 폭포수 모델의 장단점

  - 장점
    - 프로세스가 단순 (적용이 쉬움)
    - 프로세스 세분화 가능
    - 중간 산출물(deliverable)이 명확, 관리하기 좋음
    - 각 단계의 전담 팀을 구성하여 파이프 라인 작업 가능
  - 단점
    - 순환적인 흐름인 경우 따라가기 어려움
    - 이전 단계의 문제가 발견되지 않을 경우 문제가 커짐
    - 변경에 취약 -> 변경 이후 과정 반복
    - 시스템 완성 후 테스트 진행 -> 결함을 늦게 발견
    - 요구사항을 초기에 구체적으로 기술하는 것이 어려움

---

### V-Model

- V-Model: 검증을 강화하는 관점에서 폭포수 모델을 확장한 모델
  1. 요구 분석 (8 단계로 검증)
  2. 시스템 설계 (7 단계로 검증)
  3. 상세 설계 (6 단계로 검증)
  4. 코딩 (5 단계로 검증)
  5. 단위 테스팅 (4 단계 검증)
  6. 통합 테스팅 (3 단계 검증)
  7. 시스템 테스팅 (2 단계 검증)
  8. 인수 테스팅 (1 단계 검증)

---

### 프로토타이핑 모델

- 프로토타이핑 모델

  - 요구 분석 과정에서 프로토타입을 만들어 사용자에게 보여줌

    -> 요구 사항에 대한 피드백을 받기 위해

  - 점진적으로 시스템을 개발해 나감

    -> 사용자 요구가 만족된 것으로 확인되면 목표 시스템 구현

- 프로토타이핑 적용

  - 개발 착수 시점에 요구가 불투명할 때
  - 실험적으로 실현 가능성을 타지해 보고 싶을 때
  - 혁신적인 기술을 사용해 보고 싶을 때

- 프로토타입 종류

  - 일회용: 한 번 쓰고 버림, 단순한 요구 추출
  - 진화형: 계속 발전시켜 나감, 제작 가능성 타진

- 공동의 참조 모델

  - 사용자와 개발자의 의사소통을 도와주는 좋은 매개체
  - 요구사항 이해, 기술적 능력 확인

- 프로토타이핑의 장단점

  - 장점
    - 사용자의 의견 반영이 잘 됨
    - 생각지 못한 기능과 서비스 발견
    - 사용자가 더 관심을 가지고 참여
    - 개발자는 요구를 더 정확히 수용
  - 단점
    - 프로토타입 개발 비용
    - 사용자 오해, 기대심리 유발
    - 문서화 과정 축소 -> 관리가 어려움

---

### 나선형 모델

- 나선형 모델 (Spiral Model) (핵심은 risk를 줄이려 한다는 것)

  - 다음 4단계를 반복 순환함으로써 시스템 확대

    1. 목표, 방법, 제약 조건 결정 (Determine objectives)
    2. 위험 요소 분석 및 해결 (Identify and resolve risks)
       - 계속(go)할지 중단(no-go)할지 결정
    3. 개발과 평가 (Development and test)
    4. 다음 단계의 계획 (Plan the next iteration)

  - 소프트웨어의 기능을 나누어

    점증적으로 개발

    - 위험 분석 (risk analysis)

      -> 실패의 위험을 줄임

    - 테스트 용이

    - 피드백

    - 점증적인 릴리스 (Incremental releases)

- 나선형 모델 적용

  - 재정적, 기술적 위험이 큰 경우

    -> 성과를 보고 조금씩 투자해서 위험 분산

  - 요구 사항, 이해가 어려운 경우

- 나선형 모델 장단점

  - 장점
    - 대규모 시스템 개발에 적합 - risk reduction mechanism
    - 반복적인 개발 및 테스트
    - 한 사이클에 추가 못한 기능은 다음 단계에 추가 가능
  - 단점
    - 관리가 복잡
    - 위험 분석을 잘못하여 지나친 경우 피해가 큼
    - 성공 사례가 많이 알려지지 않음 (상대적으로 최신 방법)

---

### 진화적 모델

- 진화적 모델 (Evolutionary Model)
  - 시스템을 여러 사이클로 나누어 개발
  - 폭포수 모델 + 프로토타이핑 모델
  - 초기 개발 시간과 비용을 절약할 수 있음
  - 객체지향 기술 발전과 함께 객체지향 패러다임에 적합한 Unified Process 모델로 제안되어 사용되고 있음
- 릴리즈 구성 방법
  - 점증적 (Incremental) 방법
    - 릴리즈 때마다 기능을 추가
    - 요구 사항을 여러 서브 시스템으로 나눔
    - 일부 기능만 구현 -> 릴리즈 -> 새로운 기능 추가 -> 릴리즈 -> ...
  - 반복적 (Iterative) 방법
    - 릴리즈 때마다 기능의 완성도를 높임
    - 요구 사항 전체를 반영한 시스템 개발 후 완성도를 높임
- 진화적 모델 장단점
  - 장점
    - 기능이 부족하더라도 초기 사용 가능
    - 초기에 모든 요구사항을 확정할 필요 없음
    - 개발 도중 요구를 추가로 반영하기 쉬움
    - 빠른 시장 선점
    - 운영 중인 시스템의 문제를 신속히 발견하고 수정 가능
  - 단점
    - 소규모 프로젝트에 적합하지 않음
    - 끝이 안보일 수 있어 실패의 위험이 커짐
    - 최종 비용이 예산을 초과할 수 있음
    - 추가된 기능이 이전 릴리즈와 구조적으로 충돌 가능

---

### Unified Process

- Unified Process (use case 위주, 진화적 모델은 그렇지 않음)

  - 개요

    - Use Case 위주로 개발 초기에 아키텍쳐와 전체 구조를 확정함

    - 각 단계가 여러 번의 반복 과정을 통하여 완성됨

    - 각 단계는

      1. 도입 (inception, 간단한 use case 반영)
      2. 정련 (elaboration, 대부분의 use case 반영)
      3. 구축 (construction, 모든 use case 반영)
      4. 전환 (transition, 시스템 배치)

      과정을 거침

  - 장점

    - 방법론과 프로세스가 잘 문서화 되어 있어 교육받기 좋음
    - 고객의 요구 변경과 관련된 리스크를 적극적으로 해결
    - 통합을 위한 노력과 시간을 줄일 수 있음
    - 쉽고 빠르게 코드를 재사용

  - 단점

    - 프로세스가 복잡
    - 프로젝트 참여자들의 협동, 의사소통에 대한 가이드가 없음
    - 조직화되지 않은 개발로 의도와는 다른 소프트웨어 개발로 이어질 수 있음

- Process Lifecycle

  1. 도입 (inception)
     - 1, 2회 정도 반복으로 도입 단계를 진행
     - 짧아야 함 -> 과도한 요구사항 배제
     - 간단한 use case, 소프트웨어 구조, 프로젝트 계획(비용, 일정)을 작성
  2. 정교화 (elaboration)
     - 대부분의 시스템 요구사항 파악
     - 대부분의 use case를 작성
     - 아키텍처 설계 (UML)
     - 가장 중요한 use case 설계, 구현
     - 구축 단계에 대한 계획 수립
  3. 구축 (construction)
     - 남아 있는 use case 구현하고 통합
     - 실행 가능한 릴리즈 생산 (반복 때 마다)
     - 시스템을 목표 환경에 점증적으로 설치
  4. 전환 (transition)
     - 시스템을 배치, 사용자를 교육
     - 베타 테스팅 -> 결합 수정, 기능 개선

---

### 애자일 프로세스

- 애자일 프로세스 (Agile Process)

  - 애자일 선언에 기초한 빠르고 적응력 높은 개발 기술의 총칭
  - 기존의 heavyweight 방법론을 개선하기 위한 민첩성과 실용성을 내세운 lightweight 방법론

- 애자일 프로세스 특징

  - 초기 모델의 요구 변경 처리에 소모되는 시간과 비용 극복

  - 2~6주간의 짧은 주기로 개발 반복 (진화형 모델보다 빠른 주기)

  - 실행되는 소프트웨어를 개발하여 단계적으로 시스템 전체를 완성

    -> 빠른 피드백 + 평가

- 대표 모델

  - eXtreme Programming
  - Scrum

- 애자일 소프트웨어 개발 가치

  - 2001년 17명의 소프트웨어 개발 리더들이 모여서 정리

  - **Individuals and Interactions** over processes and tools

    도구와 프로세스 보다는 **유능한 사람들이** 효과적으로 협력하는게 중요

  - **Working Software** over comprehensive documentation

    문서는 사용자와 개발자의 이해를 돕지만 **목적은 실행되는 소프트웨어** 를 만드는 것

  - **Customer Collaboration** over contract negotiation

    계약은 중요하지만 **사용자와 협력을 통해 요구를 변경** 해 나가는 것이 중요

  - **Responding to Change** over following a plan

    프로젝트 개발 계획은 중요하지만 **변화에 적응** 하기 위해서는 너무 엄격하면 안됨

---

### 익스트림 프로그래밍

- 익스트림 프로그래밍 (eXtreme Programming, XP)

  > 고객이 원하는 양질의 소프트웨어를 빠른 시간안에 전달

- 특징

  - 짧은 개발 주기, 잦은 릴리즈

  - 개발 문서 < 소스 코드

  - 코딩 시 테스트 코드 작성

    -> 테스트를 중심으로 프로젝트 진행

- 익스트림 프로그래밍 적용

  - 요구가 시시각각 변할 때
  - 비교적 소규모 그룹에서

- 익스트림 프로그래밍 실천 방법

  - Whole team

    - 팀 단위 프로젝트
    - **팀 안에는 user 도 포함되어 있다.**

  - 사용자 스토리

    - 간단한 사용자 스토리 작성 (긴 문서 x)

      예) 회원은 카테고리를 선택하여 카테고리에 속한 상품 목록을 조회한다.

    - 간단한 기능을 짧은 사이클로 구현

  - Small releases

    - 주기적으로 사용자에게 프로토타입을 보여줌
    - 데모 가능, 수정 요구 반영

  - 사용자 테스트 (Customer tests)

    - 사용자가 원하는 제품이 맞는지 확인 가능 -> 사용자의 요구에 맞게 수정

  - 테스트 주도 개발 (Test-Driven Development, TDD)

    - 코딩 전에 요구사항 검증 시나리오 작성 -> 요구 명확 -> 설계 단순
    - 작성한 코드를 표준에 맞게 리팩토링

  - 짝 프로그래밍 (Pair programming)

    - 두 명의 프로그래머가 함께 작업
    - 한 명이 코딩 다른 한명은 확인
    - 수시로 검토하여 프로그램의 품질 높임
    - 지식 공유로 문제를 단시간에 해결

---

### 스크럼 (Scrum)

- 개요

  - 개발팀 모두 협력(스크럼)하여 짧은 사이클을 반복하여 개발

  - 할 일(backlog)을 정하고 우선순위를 부여

  - 짧은 주기 (sprint) 반복

  - **매일 scrum meeting**

    -> 진도 확인, 상호 이해 증진

- 장점

  - 소프트웨어를 빠르게 배포 가능
  - 요구 처리 시간 짧음 -> 즉각적인 피드백 가능
  - 문제와 결함 빨리 감지
  - 계층적 관료주의와 불필요한 문서에 시간을 덜 씀

- 단점

  - 문서화 적음 -> 새로운 개발자가 적응하기 힘들 수 있음
  - 고객과 지속적으로 상호작용 해야 함 -> 모든 사람의 에너지 소모
  - 끝이 명확하지 않을 수 있음

---

## 방법론

- 프로세스

  - 일반적으로 개발할 때 할 작업만을 명시

  - 어떤 관계가 있는지 나타내지 않음

    -> 개발 조직이 방법론을 선택하도록 함

  - 각 단계의 입력, 결과물 정함 (표현방법은 정하지 않음)

- 방법론

  - 소프트웨어 프로세스의 각 작업을 어떻게 수행하는가를 정의

  - 결과물의 표현방법이 패러다임에 따라 바뀔 수 있음

    예) 개게지향 패러다임 -> 객체의 상호작용으로 표현

  > 방법론은 프로세스가 구체적으로 구현된 것

---

### 구조적 방법론

- 구조적 분석 / 설계 방법론

  - 1970년대 제안, 1980년대 활발히 사용

- 구조적 분석

  - 실세계 문제를 process 관점으로 모델링

  - Data Flow Diagram (DFD) 사용 -> 자료의 흐름을 edge로 표시

  - 분할 정복 (divide and conquer) 적용

    - 시스템 전체를 하나의 프로세스로 보고 최상위 레벨 DFD를 그림

    - 복잡한 문제를 단순한 프로세스로 분할 -> 단순한 말단 프로세스
    - 말단 프로세스의 입력, 출력, 자료구조, 알고리즘 명시

  - DFD는 자료의 흐름 표시 (제어 흐름 x)

    -> **DFD는 소프트웨어 모듈 사이의 관계를 나타내지 못함**

    -> 구조적 설계로 보완

- 구조적 설계

  - DFD를 구조도로 변경하는 과정
    - 구조도 (structure chart): 모듈 사이의 관계를 나타내는 그래프
      - Node -> 모듈 (=함수)
      - Edge -> 서브루틴 호출 (=함수 호출)