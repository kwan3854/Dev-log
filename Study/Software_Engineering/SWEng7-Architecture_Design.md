# 아키텍처 디자인

## 1. 아키텍처

### 소프트웨어 아키텍처란

- 서브시스템 수준의 덩어리화(chunking) 작업
- 높은 추상 수준의 구성요소(클래스, 프로세스, 프로그램 등)의 구조, 관계, 연결 유형, 상호작용
- 좋은 아키텍처는 비기능적 품질을 향상시킴
- 예) 웹 서비스 -> 클라이언트-서버 아키텍처

### 아키텍처의 역할

- 시스템의 구조를 확립 (소프트웨어 개발의 중심)
- 설계, 구현, 테스팅까지 통합하는 뼈대
- 모든 단계에 영향을 줄 만한 초기 의사 결정의 핵심
- 시스템 동작 성패를 판가름

### 아키텍처 표현

- 관계자(stakeholder)들이 이해하기 쉽게 추상화
  - 외부에서 보일 수 있는 구조적 속성만 표시
  - 컴포넌트는 블랙박스로 명시
- 계층적 분할 (hierarchical decompositions)
  - 컴포넌트들을 단계적으로 분할
  - 관계자들은 자신이 관심있는 계층만 참조
  - 개발자들에게 위임 가능한 부분은 분할하지 않음
- 패키지 다이어그램 (Package Diagram)
  - 패키지: 연관된 클래스들을 그룹화한 것
  - UML 에서 서브시스템을 표현

## 2. 아키텍처 스타일

### 아키텍처 스타일이란

구성 요소 유형에 대한 설명 및 런타임 제어, 데이터 전송에 대한 패턴이다.

- 시스템 분할, 전체 제어 흐름, 오류 처리 방침, 서브시스템 간의 통신 프로토콜 포함
- 예) 웹, ftp, 이메일 -> 클라이언트-서버 스타일

### 주요 스타일

- 클라이언트-서버
- 계층형
- 이벤트 주도
- MVC
- 파이프 필터
- 데이터 중심
- Peer-to-Peer

### 클라이언트-서버

- 대표 사례: 웹 서비스
- 일반적인 네트워크를 사용하는 시스템 (서버 - 클라이언트 통신)
- 서버
  - 클라이언트가 요청하는 기능이나 자원을 제공
  - 강력한 성능으로 자원관리 (데이터, CPU, 프린터 등)
  - 많은 클라이언트에게 동시에 서비스 제공
- 클라이언트
  - 기능이나 자원의 사용을 위하여 서버에 접속
- 유형
  - 무거운 클라이언트: 클라이언트에서 데이터 처리
  - 가벼운 클라이언트: 서버에서 데이터 처리
- 장점
  - 데이터 집중화: 데이터를 서버에 집중시켜 단순화
  - 보안: 클라이언트 감시, 접근 제한 가능
- 단점
  - 병목: 클라이언트가 많을 경우 서버의 네트워크 부하 커짐
  - 비용: 높은 설치 비용 및 관리 비용
  - 비강인성: 단일 장애점 (single point of failure)

### 계층형 (layered, Multilayered)

- 대표 사례: 운영체제
- 복잡한 시스템을 추상 수준에 따라 층을 나눔
- 각 층 사이는 메시지를 교환
- 장점: 추상화, 캡슐화, 응집성, 재사용성 높음
- 단점: 이웃 층과의 커뮤니케이션이 제한적, 구성이 쉽지 않음

### 이벤트 기반 (Event-Driven)

- 대표사례: ROS (로봇운영체제)
- 사건 중심의 시스템
- 이벤트 생산자: 이벤트 스트림을 생성
- 이벤트 소비자: 이벤트 수신 대기
- 이벤트
  - 실시간으로 전달
  - 발생하는 즉시 소비자가 응답
- 장점
  - 캡슐화, 응집성: 생산자 소비자 분리
  - 확장성: 새 소비자 추가 쉬움
  - 이벤트 도착 즉시 응답
- 단점
  - 복잡성: 상황에 따라 복잡한 제어 필요
  - 테스팅: 허용된 이벤트의 동작을 정확히 확인해야 함, 허용되지 않은 이벤트는 오류 메세지나 제어 필요

### MVC (Model-View-Controller)

- 대표사례: Android
- 데이터 - UI - 비즈니스 로직 분리
- 구성요소
  - Controller: 모델에 명령을 보냄으로써 모델의 상태 변경, 뷰에 명령을 보냄으로써 모델의 표시 방법 변경
  - Model: 데이터의 상태에 변화가 있을 때 뷰에 이를 통보
  - View: 모델로부터 정보를 받아서 사용자가 볼 결과물을 생성
- 장점
  - 느슨한 결합, 확장성: 다른데 영향을 주지 않고 하나의 컴포넌트만 수정 가능
  - 다수의 다른 뷰: 하나의 모델에 다양한 뷰 제공 가능
- 단점
  - 복잡도: 컴포넌트 분리로 인한 메커니즘이 복잡할 수 있음
  - 비효율성: 컴포넌트간의 메세지 전송이 비효율적

### 파이프 필터 (Pipes and Filters)

- 대표 사례: 컴파일러 (cpp - cc - as)
- 필터 사이에 데이터를 이동시키며 단계적으로 처리 (단방향)
- 데이터의 변환을 수행하는 필터로 구성
- 장점: 단순성, 재사용, 병렬성
- 단점: 자원의 낭비, 오류 처리 힘듦

### 데이터 중심 아키텍처 (Data-Centric)

- 대표 사례: github
- 공유 데이터가 중요한 시스템
- 구성요소
  - 공유 데이터 저장소: 공유 데이터 저장
  - 공유 데이터 접근자: 공유 데이터를 추가, 삭제 및 수정
- 장점: 낮은 결합, 확장성
- 단점: 단일 장애점 (single point of failure)

### Peer-to-Peer 스타일

- 대표 사례: 블록 체인
- 동등한 컴포넌트가 서버-클라이언트 역할을 동시에 수행
- 동일한 수신, 전송 데이터 양을 가지므로 대칭적인 시스템
- 장점: 전담 서버 없음, 확장성, 신뢰성, 고장에 강함
- 단점: 보안 취약, 중앙 제어 어려움, 성능 저하

---

