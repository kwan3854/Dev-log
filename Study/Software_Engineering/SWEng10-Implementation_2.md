# 구현 (Implementation) (Part 2)

## 1. 리팩토링 (Refactoring)

### 리팩토링

- 결과의 변경 없이 코드의 구조를 재조정
- 이미 존재하는 코드의 디자인을 안전하게 향상
- 가독성을 높이고 유지보수를 펺라게 하기 위한 것

### 목적

- 소프트웨어의 디자인을 개선
- 소프트웨어를 이해하기 쉽게 변경
- 버그를 찾는데 도움을 줌
- 프로그램을 빨리 작성할 수 있게 도와줌

### 리팩토링 과정

1. 소규모의 변경 - 단일 리팩토링
2. 코드가 전부 잘 작동되는지 테스트
3. 잘 작동하면 다음 리팩토링 단계로
4. 작동하지 않으면 문제를 해결
   - 리팩토링 한 것을 undo 하여 시스템이 작동되도록 유지

### Code Smell

문제가 생길 수 있는 코드의 특징

| Code Smell                      | 설명                                                         | 리팩토링                                                     |
| ------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Duplicated code                 | 중복된 코드가 여기저기 있음                                  | 중복을 제거                                                  |
| Long method                     | 메소드의 내부가 너무 긺                                      | 메소드를 적정 수준의 크기로 나눔                             |
| Large class                     | 클래스에 너무 많은 속성과 메소드가 존재                      | 클래스의 몸집을 줄임                                         |
| Long parameter list             | 메소드의 파라미터 개수가 너무 많음                           | 파라미터의 개수를 줄임                                       |
| Divergent class                 | 한 클래스가 2가지 이상의 이유로 수정되는 경우                | 한 가지 경우에만 수정되도록 변경                             |
| Shotgun surgery                 | 하나의 변경이 여러 클래스를 수정                             | 여러 클래스에 흩어진 유사한 기능을 한곳에 모음               |
| Feature envy                    | 빈번히 다른 클래스의 데이터를 얻어 와서 기능 수행            | 메서드를 그들이 애용하는 데이터가 있는 클래스로 옮김         |
| Data clumps                     | 3개 이상의 데이터 항목이 여러 곳에 중복되어 나타남           | 해당 데이터들을 독립된 클래스로 정의                         |
| Prmitive obsession              | 객체 형태 그룹을 만들지 않고, 기본 데이터 타입만 사용        | 같은 작업을 수행하는 기본 데이터의 그룹을 별도의 클래스로 만듦 |
| Switch statements               | switch 문장이 지나치게 많은 case를 포함한다                  | 다형성으로 변경 (같은 메소드를 가진 여러 개의 클래스로 구현) |
| Parallel Inheritance Hierachies | Shotgun Surgery의 특별한 형태. 한 class 에서 subclass 를 생성하면 다른 모든 class도 subclass 생성해야 함 | 다른 계층의 참조를 유지하고 메서드와 필드를 이동하여 중복 제거 |
| Lazy class                      | 클래스를 유지하고 이해 하는데 비용이 발생                    | inline class 로 변경, 클래스 삭제                            |
| Speculative Generality          | 별 일을 하지 않는 추상 클래스                                | inline class 로 변경, 삭제                                   |
| Temporaty field                 | 사용되지 않는 것 같은 변수가 존재                            | 메서드와 묶어서 클래스로 추출                                |

### 리팩토링 사례

- 메서드 추출

  중복되는 긴 코드를 메서드로 만듦

- 클래스 추출

  여러 기능의 클래스를 단일 기능의 클래스 여러 개로 분할

- 서브 클래스 추출

  특정 인스턴스에만 유용한 특성을 서브 클래스로 분리

  ```java
  public class Customer {
    String name;
    String jobTitle;
  }
  ```

  ```java
  public class Customer {
    String name;
  }
  
  public class Employee {
    String jobTitle
  }
  ```

- 메서드 이동

  메서드가 정의된 클래스보다 다른 클래스의 기능을 많이 사용할 경우

## 2. 코드 품질 향상 기법

### 코드 품질 향상 기법

- 코드 인스펙션 (Code inspection)

  프로그램을 읽어보고 눈으로 확인

- 정적 분석 (Static analysis)

  수행되지 않는 데드 코드가 없는지, 선언이 되지 않고 사용한 변수가 없는지 등을 검사

- 테스트 중심 개발 (TDD, Test-Driven Development)

  - 테스트 코드 작성 후 개발
  - 오류를 줄일 수 있음

- 페어 프로그래밍 (Pair programming)

  두 사람이 머신을 공유하며 함께 코딩

### 코드 인스펙션

- 설계나 코드 결함과 품질(효울, 코딩 표준 준수 등) 저하 등을 찾음

- 품질 개선, 결함 초기 발견

- 성공적으로 컴파일 되고 정적 분석 도구에 의하여 검사된 후 수행

  -> 자동으로 찾아지는 오류를 찾지 않아도 됨

- 체크리스트를 프로그래머, 설계자, 테스트 엔지니어에게 전달

- 결함의 타입

  - 로직 문제
    - case 빠짐, 중복 로직, 조건 빠짐, 불필요한 기능, 루프 결함 등
  - 컴퓨팅 문제
    - 잘못된 수식, 오차, 부호 오류 등
  - 인터페이스/타이밍 문제
    - 인터럽트 처리 오류, I/O 타이밍 부정확, 서브루틴/모듈 불일치
  - 데이터 처리
    - 초기값 부정확, 데이터 접근 부정확, 자료의 단위 부정확, 벡터의 차원 부정확 등

### 정적 분석

- 프로그램 텍스트를 조직적으로 분석하여 결함을 찾아내는 것
- 소프트웨어 도구를 이용하여 자동으록 가능
- 자료 변칙 (data anomaly)
  - 자료 흐름도(data flow diagram)를 분석하여 자료가 정의되지 않고 사용되거나, 정의되고 사용되지 않는 비정상적인 패턴을 찾는 것
- 사족 (redundant)
  - 일반적으로 컴파일러에 의하여 검출되지 않음
  - 할당문 중복, 데드 코드, 조건 중복 등

### 테스트 중심 개발 (TDD)

- 테스트를 위한 코드를 작성한 후 기능을 구현
- 주로 클래스 안에 있는 메서드를 테스트 (단위 테스트)
- 개발 과정

### 짝 프로그래밍 (Pair Programming)

- 두 사람이 같은 컴퓨터를 사용하면서 같이 코딩
- 장점
  - 스트레스와 성공의 기쁨을 나눌 상대가 있기 때문에 프로그래밍에 재미가 있고 압박을 줄일 수 있음
  - 파트너와 아이디어를 교환하기 때문에 팀의 소통을 향상시킬 수 있음
  - 팀 구성원이 서로를 이해하고 여러 가지 방법을 서로 배울 수 있음
  - 토론을 통한 창의적인 사고로 문제 해결에 도움이 됨
- 단점
  - 팀프로젝트의 단점과 같음
  - 비효율적
  - 스케줄 문제
  - 스타일의 차이

---

