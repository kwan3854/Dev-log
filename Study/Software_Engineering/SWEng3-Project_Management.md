# Project Planning and Management

## 프로젝트 관리 (Manaement)

- 프로젝트 관리의 목적
  - 작업 수행에 필요한 여러가지 자원, 인력, 비용, 재료, 기술 등을 가장 효과적으로 사용하여 프로젝트의 목표를 달성하는 것
- 관리의 어려움
  - 개발 대상이 눈에 보이지 않는다
  - 소프트웨어 분야의 기술 발전은 매우 빠르다
  - 소프트웨어 분야는 조직마다 프로세스가 다르다
- 관리 활동의 요소
  - 계획
  - 조직
  - 모니터링
  - 조정

---

## 1. 프로젝트 시작

- 목표를 세우고 가치와 리스크를 이해
- 결정 요인
  - 프로젝트가 제공할 가치
  - 프로젝트와 관련된 리스크
- 가치를 평가하는 방법
  1. 투자 회수 기간
  2. ROI(Return of Investment)
  3. 순수 현재 가치
  4. 평가표
  5. SWOT

---

## 2. 리스크와 타당성

- 위험 요인
  - 자원, 현재 사용량과 가용성, 예상 사용량과 가용성, 프로젝트의 우선 순위 및 중요도
  - 시간
  - 기술적 어려움
- 타당성 분석
  1. SOW - 프로젝트가 성취하여야 할 일 (Statement of Work)
  2. 비즈니스 목표(가치) - 프로젝트의 결과물
  3. 예산 - 비용과 수익의 요약
  4. 프로젝트 일정 - 대략적인 일정
  5. 프로젝트 리스크 - 위험 요소
  6. 대안 - 구축, 구매 등의 방법
  7. 평가 - 프로젝트 가치에 대한 평가 결과

---

## 3. 프로젝트 계획과 스케줄링

- 초기 계획
  - 목표 설정
  - 일정 정의
  - 비용 추정
- 프로젝트 범위 정하기
- WBS (Work Breakdown Structure): 할 일을 계층적으로 분할한 것

---

### 스케줄링

- WBS를 기초로 하여 일정을 정의하는 것
  1. 작업 사이의 의존 관계 파악
  2. CPM (Critical Path Method) 방법을 이용한 여유 시간 계산 (최악의 경로 이 path 위의 일정은 여유시간 없음)
  3. 소요 자원의 할당

---

### 자원 할당과 Gantt 차트

- Gantt 차트
  - 각 업무별로 일정의 시작과 끝을 그래픽으로 표시
  - 각 업무(activities) 사이의 관계 표시

---

## 3. 비용 예측 기법

- 노력(Effort)과 자원(Manpower)과 기간(Duration)의 관계: D=E/M
  - 노력을 산정하는 것이 쉽지 않음
- 비용 예측의 중요한 변수는 투입되는 엔지니어의 인원수와 작업 기간
- 비용 예측 기법
  1. 전문가 판단
     - WBS를 기초로 전문가가 각 단계의 비용 추정
  2. PERT(Program Evaluation and Review Technique)
     - 가중 평균으로 기대치 산정
  3. 알고리즘식 방법
     - 노력을 체계적으로 결정 (함수 정의)
     - COCOMO, COCOMO II, ...

---

### COCOMO-81 (COnstructive COst MOdel, 1981)

- 최종 시스템의 규모(LoC, Lines of Code) 추정

  -> 식에 대입하여 MM (Man * Month) 구함

- 프로덕트에 영향을 주는 요인 추가 고려

  - 시스템의 유형이나 팀, 프로젝트 프로세스 등

- 완성된 프로젝트의 비용과 속성을 분석

  -> 실제 경험에 근거한 예측 공식 사용 가능 

E = a(i) * (KDSI)^b(i) * EAF

KDSI: Kilo Delivery Source Instruction

EAF: Effort Adjustment Factor

---

- EAF (Effor Adjustment Factor)

  - 프로젝트에 영향을 주는 다른 요소들 (제품 성격, 시스템 특징, 개발원 특성 등)
  - 예측한 노력을 보정 (scaling)

- EAF 계산

  - EAF = 해당 되는 항목을 모두 곱한 값

    ex) 매우 복잡(1.30)하고, 높은 신뢰도(1.15)의 소프트웨어을 개발하기 위해 요구되는 일정이 매우 촉박(1.10)할 때, 소프트웨어 공학 기술을 거의 사용하지 않는다면(1.24) 이때의 EAF수치는?

    EAF = 1.30 * 1.15 * 1.10 * 1.24 = 2.04

  - 위의 소프트웨어 KDSI가 60이고(60k 줄), semi-detached 형 프로젝트일때, 노력 E는?

    E = a(i) * (KDSI)^b(i) * EAF

    E(MM) = 3.0 * 60^1.12 * 2.04 = 600.179

---

- COCOMO-81 단점

  - 전체 시스템을 하나의 개체로 보고 인자들을 전체에 적용

  - 프로젝트 초기 단계에 KDSI 값 예측 어려움

    (기능의 규모를 예측하는 것이 더 쉬움)

  - 예측 모델 인자들(bi, EAF)이 주관적

  - 기존 프로젝트를 기반으로 보정(calibration) 해야 함

    -> 공개 데이터 사용 시 부정확

  - 객체 지향 프로젝트에 적용 어려움

---

### COCOMO II (1995)

- 규모 요인(scaling Driver)과 비용 요인(Cost Driver) 등을 이용하여 프로젝트의 생산성, 가격을 결정

- 개발 단계에 따라 세 가지 다른 모델 사용

- COCOMO에서의 개선점

  |        | COCOMO 문제점                        | 개선사항                                      |
  | ------ | ------------------------------------ | --------------------------------------------- |
  | 시기   | 설계 이전 산정 어려움                | 진행 정도별 산정 모델                         |
  | 방법   | 재사용 산성 어려움                   | 컴포넌트, 프레임워크 환경 지원                |
  | 방법   | 전체 시스템을 turnkey 방식 일괄 산정 | 서브 시스템별 개별 산정                       |
  | 방법론 | 구조적, 정보공학 방법론 기반         | Object Oriented / Component Based Design 지원 |

  

---

- COCOMO II 서브 모델

  - Application Composition (응용 합성) Model

    - 주로 GUI Builder 나 컴포넌트 들을 이용하여 조립 개발하는 경우 사용
    - UI 개수 계산 -> 객체 점수 산출 -> 소프트웨어 규모 산정

  - Early Design (초기 설계) Model

    - 초기 설계단계에서 예측 값 구함
    - 소프트웨어의 크기, 운영 환경, 수행할 프로세스 등에 대한 정보가 부족할 때

  - Post-Architecture (설계 이후) Model

    - 기능 점수를 바탕으로 LOC를 추정, 소프트웨어 규모 산정
    - 가장 세부적인 모델
    - COCOMO보다 업그레이드된 방식으로 비용 산출

    FP(Function Points) = GFP(Gross Function Points) * PCA(Processing Complexity Adjustment)

---

- 기능 점수

  - 소프트웨어 시스템 기능을 정량화

  - 구현 전에 정확한 LOC는 예측 불가능

    -> 아래의 항목으로 소프트웨어의 규모 표시

    - 입력 개수: 사용자 -> 시스템 입력 자료의 수 

    - 출력 개수: 시스템 -> 사용자 출력 자료의 수

    - 질의 개수: 특정 기능을 요청할 때 필요한 대화형 질의(Query)의 수

    - 파일 개수: 시스템이 유지 보관하는 정보의 그룹

    - 인터페이스 개수: 다른 시스템과의 인터페이스

      ex) 다른 시스템에서 만든 파일 읽음 (통신)

    - 주의사항: 입력, 출력 개수는 화면, 파일 단위의 그룹으로 카운트(세부 항목 x)

  - 경험 중심적 -> 단위 시간당 개발자의 생산성 점수 자료 필요

    한 사람이 100점의 function point 개발하려면 몇 개월 소요?

    이런것은 경험적으로 수집되어야 함.

---

- ex) 기능 점수를 이용한 노력(effort) 추정
  - 기능 수와 복잡도
    - 사용자 입력: 10개
    - 사용자 출력: 5개
    - 사용자 질의: 8개
    - 자료 파일: 30개
    - 외부 인터페이스: 4개
    - 복잡도 모두 단순
  - 처리 복잡도 (PC)
    - 신뢰도 높은 백업 필요 (PC1 = 5)
    - 사용 친근성 매우 높음 (PC14 = 5)
    - 나머지 보통
  - 개발팀 생산성
    - 주당 60FP 구현 가능

---

- GFP 계산

  |      | 기능 분야       | 개수 | 복잡도: 단순 | 복잡도: 중간 | 복잡도: 복잡 | 개수 X 가중값 |
  | ---- | --------------- | ---- | ------------ | ------------ | ------------ | ------------- |
  | 1    | 입력            | 10   | 3            | 4            | 6            | 30            |
  | 2    | 출력            | 5    | 4            | 5            | 7            | 20            |
  | 3    | 질의            | 8    | 3            | 4            | 6            | 24            |
  | 4    | 파일            | 30   | 7            | 10           | 15           | 210           |
  | 5    | 응용 인터페이스 | 4    | 5            | 7            | 10           | 20            |
  | 6    |                 |      |              |              | GFP          | 304           |

  

---

- PCA 계산

  PCA = 0.65 + 0.01*(PC1 ~ PC14의 합) -> (0.65 <= PCA <= 1.35)

  0: 영향없음, 1:미미, 2:약간, 3:보통, 4:상당, 5:많음

  표를 보고 구해봤더니 1.11이 나왔다고 해보자.

---

- FP 계산

  FP = GFP * PCA = 304 * 1.11 = 337.44

  FP 는 타겟 시스템의 규모이다.

- 노력 (Effort) 계산

  E = FP / Productivity = 337.44 / 60 = 5.624 person-weeks

---

- FP는 구현 언어에 관계 없는 메트릭

- 구현 언어의 고려

  - 기능점수 1점을 구현하는데 필요한 코드 라인 수

    |   언어    | 라인 수 |
    | :-------: | :-----: |
    | 어셈블리  |   324   |
    |     C     |   150   |
    |  Pascal   |   91    |
    |    Ada    |   71    |
    |    APL    |   32    |
    | Smalltalk |   21    |

  - 총 라인수 = FP * 원하는 언어의 1점 당 LOC

  - 개발 노력 = 총라인수 / 생산성

    = (LOC/MM)

---

## 4 프로젝트 팀 조직

- 프로젝트 팀 조직 (역사적으로 기계적인 조직에서 유기적인 조직으로 발전함)
  - 소프트웨어 개발 생산성에 영향
  - 팀간 협력이 잘 되어야 함
- 프로젝트 팀 조직 정의
  - 역할과 책임이 어디에 있는가?
  - 어떤 통로로 정보가 전달되고 결정되는가?
  - 어떻게 갈등을 해소할 것인가?
- 직무 능력에 따른 분류

---

### 직능별 조직 (Functional Organization)

- 전통적인 방법

- 서로 다른 부서가 한 프로젝트의 다른 단계에 들어와 작업 수행

- 팀원은 한 부서에 소속, 프로젝트의 협력은 부서별로

- 직능별 조직 특징

  - 효율적인 인력 운용 (pipelining)
  - 전문지식 공유로 개인의 기술 발전 -> 기업 노하우
  - 팀원은 한 부서에 소속 (관리자 1명) -> 관리 용이
  - 부서별로 프로젝트 협력 -> 작업내용 전달체계 필요

  | 장점                                     | 단점                                                |
  | :--------------------------------------- | --------------------------------------------------- |
  | 전문성, 전문가 활용성 높음 (전문가 Pool) | 부서간 책임분산으로 통합 기능 부재 및 갈등발생 가능 |
  | 조직체계 변경 없음                       | 부서 관점의 편협된 의사결정                         |
  | 명확하게 정의된 책임과 역할이 있음       | 동기부여 부족                                       |
  |                                          | 요구사항에 대한 대응이 느림                         |

---

### 프로젝트 별 조직 (Project Organization)

- 직능별 개발자들이 프로젝트에 배정

- 의사 전달 경로가 짧으며, 인력, 진도 등 프로젝트 관리가 수월

- 프로젝트별 조직 특징

  - 단계별 의사 전달 경로가 짧음
  - 인력, 진도 등 프로젝트 관리가 수월
  - 프로젝트별 독립성 유지
  - 고객이 개발팀과 접촉 쉬움

  | 장점                                         | 단점                                          |
  | -------------------------------------------- | --------------------------------------------- |
  | 조직구조 간단함 (의사소통과 보고체계가 명확) | 인력 낭비(중복) 발생                          |
  | PM의 권한이 높음 (프로젝트 추진력이 강함)    | 노하우가 기술의 개인의존으로 기술 전문성 제약 |
  | 과업 지향적, 동질적인 팀 분위기 형성         | 프로젝트 완료 후 팀원들의 소속팀 복귀 불안    |
  | 신속한 의사결정 및 진행 가능                 | 전사 표준 적용의 일관성 결여 우려             |

---

### 직능별 조직과 프로젝트별 조직 비교

**장점**

| 직능별                   | 프로젝트별             |
| ------------------------ | ---------------------- |
| 효과적인 인력 사용       | 일정 및 비용 관리 용이 |
| 전문성 유지 및 개발 용이 | 고객과의 연결이 간단   |
| 기술 전수 용이           | 빠른 회신              |
| 개인 소통 덜 요구        | 커뮤니케이션 간단      |
|                          | 관리, 교육 용이        |
|                          | 프로젝트 파악 쉬움     |

**단점**

| 직능별               | 프로젝트별                |
| -------------------- | ------------------------- |
| 고객 인터페이스 약함 | 기술적 불확실성           |
| 프로젝트 관리 취약   | 전문가 사용이 비효율적    |
| 수평적 소통 취약     | 미래 작업의 배정 불투명   |
| 회신이 느림          | 프로젝트간 기술 교류 취약 |

---

### 매트릭스 조직 (Matrix Organization)

- 프로젝트별 조직 + 직능별 조직
- 각 인력은 직능별 조직에 소속됨
- 필요한 때에 프로젝트에 참여
- 두 명 이상의 관리자 (직능별 팀, 프로젝트 팀) 필요
- 커뮤니케이션이 복잡함
- Strong, weak, balanced

| 장점                                         | 단점                                                |
| -------------------------------------------- | --------------------------------------------------- |
| 조직 자원의 활용 효율성 높음                 | 조직 체계, 권한, 보고체계가 복잡                    |
| 수직, 수평의 정보공유 용이                   | 의사결정기간 장기화 우려                            |
| 직능별 조직과 프로젝트 조직의 장점 활용 가능 | 희소 자원에 대한 부서간 갈등 발생                   |
|                                              | 직능별 조직과 프로젝트 조직의 단점만 나타날 수 있음 |

---

### 애자일 조직 (Agile Organization)

- 구성원 상호작용, 고객과의 협력, 요구 변경을 중요하게 여김

  -> 서로 밀접하게 협력하는 5~9명의 팀 구성

- 결과와 이슈에 대한 오너쉽을 공유

- 고객의 요구와 가치 만족을 위해 융통성 있는 조직 구성

- 다양한 형태의 팀 구성

- 규모가 큰 프로젝트에 맞지 않음

---

## 5. 실행과 모니터링

*프로젝트 실행 동안 모니터링 -> 계획과 비교 -> 변경*

---

### 5.1 프로젝트 실행

- 관리 작업
  - 작업 시작 미팅
    - 팀의 작업 목표와 형식 확인
  - 작업 결과 수집
    - 결과물을 체계적으로 수집 (repository)
    - 진행 상황을 정기적으로 수집 or 필요한 때에 수집
    - 정성적인 정보도 수집 가능

---

### 5.2 프로젝트 모니터링

- 목적: 프로젝트 현황 (범위, 일정, 비용, 진척도, 품질 등) 파악, 차이 분석과 조치

- 차후 프로젝트를 위한 데이터 수집과 분석

- 일정 모니터링

  - 계획된 일정과 실행 현황 (시작, 종료, 들어간 노력 등) 비교

  - 노력을 시간단위로 호나산하여 모니터링 가능 (표)

    -> 진행상황을 한눈에 알기 어려움

---

### 5.2.1 어닝 밸류 분석 (Earning Value Analysis)

- 비용과 일정을 통합된 방법(같은 단위)으로 모니터링
- 계획된 노력(비용), 실제 진척도(어닝 밸류), 노력(실제 비용)을 금전적 가치로 환산하여 모니터링 (*Man-power를 비용으로 환산)
- 과정이 복잡하지만 전체 진척 상황을 이해하기 쉬움

---

### 5.2.2 번다운 차트 (Burn Down Chart)

- 남아있는 일 대비 시간을 그래프로 표현
- 모든 일이 완성될 시점을 예측하는데 유용
  - 남아있는 일 대비 시간을 그래프로 표현
  - 모든 일이 완성될 시점을 예측하는데 유용

---

## 6. 리스크 관리

### 리스크 관리

- 위험이 발생되었을 때의 영향을 줄이는 것
- 프로젝트 목적 달성을 위한 다양한 불확정성을 다룸
- 리스크 해소 방법을 찾고, 프로젝트 실행하는 동안 이를 적용
- 방법
  - 리스크를 피하기 위하여 계획을 변경
  - 책임을 다른 기관에 맡김
  - 프로토타이핑
  - 유능한 인재 등용
  - 3자와 협업

---

### 리스크 파악

- 프로젝트에 영향을 주는 리스크를 파악하고 문서화
- 리스크 찾는 방법
  - 회의
  - 문서 분석
  - 리스크 분할 구조, 체크리스트
  - 유추

---

### 리스크 평가

- 리스크를 영향도에 따라 평가하고 우선순위를 매김

  - 발생 빈도, 발생했을 때 미치는 영향이 우선 순위 좌우

- 종류

  - 정량적 평가 (Quantitiative Analysis)

    - 리스크 확률을 고려한 영향을 돈으로 환산하여 평가

  - 정성적 평가 (Qualitative Analysis)

    - 주관적인 방법으로 평가

    - 리스크 발생 확률에 대한 정확한 정보가 없을 때 활용

    - Risk Matrix 활용

      Risk = Likelihood * Consequence

---

