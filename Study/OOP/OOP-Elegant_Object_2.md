# 3. Employment 취업

## 3.1 5개 이하의 public 메서드만 노출하세요

가장 우아하고, 유지보수가 가능하고, 응집력이 높으면서, 테스트하기도 용이한 객체는 작은 객체이다.

클래스의 크기를 정하는 기준으로 public 메서드(protected 메서드 포함)의 개수를 사용하기를 권장한다.

클래스 안에 포함된 public 메서드가 5개보다 적다면 만족스러운 수준이다. 5개보다 많다면 클래스를 리팩토링 할 필요가 있다.

- public 메서드는 5개 이하 (protected 포함)
- 생성자는 제외

## 3.2 정적 메서드를 사용하지 마세요

OOP 에서 static 은 순수악이다.

정적 메서드의 사용을 중단해야 한다.

### 3.2.1 객체 대 컴퓨터 사고 (object vs computer thinking)

순차적인 사고 방식을 컴퓨터 입장에서 생각하기라고 부른다. (어셈블리, C)

함수형 프로그래밍을 하면 CPU에게 할 일을 지시하는게 아니라 정의한다.

객체지향 프로그래밍이 절차적 프로그래밍과 차별화되는 점이 바로 'is a' 이다.

OOP의 정적메서드는 C와 어셈블리어의 서브루틴과 동일하다.

이것은 잘못된 방식이다.

### 3.2.2 선언형 스타일 대 명령형 스타일 (declarative vs imperative style)

- 명령형 프로그래밍:

  프로그램의 상태를 변경하는 문장을 사용해서 계산 방식을 서술

- 선언형 프로그래밍:

  제어 흐름을 서술하지 않고 계산 로직을 표현

선언형 방식이 명령형 방식보다 더 좋다.

1. **더 빠르다**

   선언형 방식에서는 우리가 직접 성능 최적화를 제어할 수 있다.

   현재의 언어에서는 명령형 방식이 선언형 방식보다 더 빠르다.

   하지만 다수의 정적 메서드를 호출해야 하는 경우에는 필요한 메서드만 선택적으로 호출할 수 있는 객체 방식이 더 빠르다.

   즉, 선언형 방식이 더 빠르다.

   실행 관점에서 선언형 방식이 더 최적화되기 때문이 더 빠르다는 것.

2. **다형성**

   다형성이란 코드 블록 사이의 의존성을 끊을 수 있는 능력.

   생성자의 인자로 객체를 전달할 수는 있지만 정적 메서드를 전달하는 것은 불가능.

   객체를 다른 모든 객체로부터 완전히 분리하기 위해서는 어떤 메서드나 주ctor 안에서도 new 연산자를 사용해서는 안됨.

3. **표현력**

   선언형 방식은 결과를 이야기하는데 반해, 명령형 방식은 수행 가능한 한 가지 방법을 이야기 한다.

   명령형 스타일이 알고리즘과 실행을 다루는 방법이라면, 선언형 스타일은 정확하게 객체와 행동에 관한 방법이다.

4. **응집도**

정적 메서드는 객체지향 소프트웨어의 암적인 존재이다.

### 3.2.3 유틸리티 클래스

유틸리티 클래스란 실제로는 클래스가 아니라 편의를 위해 다른 메서드들이 사용하는 정적 메서드를 모아 놓은 정적 메서드들의 컬렉션(다른 말로 헬퍼 라고도 부른다).

유틸리티 클래스를 클래스라고 부르기 어려운 이유는 인스턴스를 생성하지 않기 때문이다.

유틸리티 클래스는 어떤 것의 팩토리가 아니기 때문에 진짜 클래스라고 부를 수 없다.

유틸리티 클래스를 구현할 때는 클래스의 인스턴스가 생성되는 것을 방지하기 위해 prvate ctor를 추가해주는 것이 좋다.

유틸리티클래스는 끔찍한 안티 패턴이다. 가까이하지 말아라.

### 3.2.4 싱글톤(Singleton) 패턴

싱글톤 패턴은 정적 메서드 대신 사용할 수 있는 매우 유명한 개념이다.

싱글톤은 유명한 디자인 패턴이지만 사실 끔찍한 안티 패턴이다.

싱글톤과 유틸리티 클래스 사이의 차이점을 묻는 질문에 대해 싱글톤은 상태를 유지한다고 답하는 개발자가 많다.

하지만 이 대답은 틀렸다. 싱글톤의 목적은 상태를 유지하는 것이 아니다.

싱글톤은 분리 가능한 의존성으로 연결되어 있는데 반해, 유틸리티 클래스는 분리가 불가능한 하드코딩된 결합도를 가진다.

캡슐화된 객체를 변경할 수 있기 때문에 싱글톤이 유틸리티 클래스보다는 더 좋다는 것.

싱글톤이 유틸리티 클래스보다 낫다고는 하지만 여전히 안티패턴이자 형편없는 개념일 뿐이다.

싱글톤은 전역 변수 그 이상도 그 이하도 아니다.

싱글톤은 객체지향 패러다임을 잘못 사용한 예이며, 싱글톤을 사용하지 마라.

싱글톤 대신 각각의 객체 안에 캡슐화 하는 방식을 사용해라.

### 3.2.5 함수형 프로그래밍

객체의 크기가 작고, 상태가 변하지 않으며 정적 메서드도 포함하지 않는다면, 함수형 프로그래밍을 활용하는 편이 더 낫지 않을까?

답은 아니다.

함수형 프로그래밍 보다 OOP의 표현력이 더 뛰어나고 강력하기 때문.

함수형 프로그래밍에서는 오직 함수만 사용할 수 있지만 OOP에서는 객체와 메서드를 조합할 수 있다.

함수형 프로그래밍은 훌륭한 패러다임이지만, OOP가 더 낫다.

### 3.2.6 조합 가능한 데코레이터

조합 가능한 데코레이터는 그저 다른 객체를 감싸는 객체일 뿐이다.

이것은 유명한 디자인 패턴인 데코레이터일 뿐이지만, 이 데코레이터 객체들을 다중계층 구조로 구성하기 시작하면 객체를 어떻게 만들었는지를 전혀 설명하지 않고도 이 객체가 무엇인지를 설명할 수 있다. 단지 선언만 했을 뿐인데.

프로그래머는 데코레이터를 조합하는 일을 제외한 다른 일은 하지 말아야 한다.

정적 메서드는 작은 객체들을 조합해서 더 큰 객체를 만들 수 없다.

간단히 말해서 정적 메서드는 합성이라는 아이디어와 대치된다.

이것이 OOP에서 정적 메서드를 사용해서는 안되는 또 다른 이유이다.

## 3.3 인자의 값으로 NULL을 절대 허용하지 마세요

NULL은 정적 메서드 및 가변성과 더불어 객체지향 세계의 커다란 골치거리 중 하나이다.

한 마디로 말해서 코드 어딘가에 NULL이 존재한다면 여러분은 커다란 실수를 저지르고 있는 것이다.

전달할 객체가 없으므로 값이 없는 것으로 간주하세요 라는 의사를 표현할 수 있도록 사용자에게 진짜 객체 대신 NULL을 전달하도록 허용하는 것은 일반적인 방법이다.

진짜 객체라면 대화에 응할 것이고 NULL 이라면 대응하지 않겠다는 식으로 객체와 의사소통해서는 안된다.

대부분의 언어들이 더 이상 포인터를 제공하지 않음에도 불구하고, 불행하게도 객체지향 세계에서는 이 개념을 물려받고 말았다.

포인터가 없어지고 객체만 남은 상황에서 여전히 Java에 null이 존재하는 이유는 없다.

이것이 Java 언어가 안고 있는 설계 상의 커다란 실수라고 생각한다.

OOP 에서 존재하지 않는 인자 문재는 널 객체를 이용해서 해결해야 한다. 전달한 인자가 객체인지 NULL 인자인지 확인하는 짐을 메소드 구현자에게 떠념겨서는 안된다. 항상 객체를 전달하되, 전달한 객체에게 무리한 요청을 한다면 응답을 거부하도록 객체를 구현해야 한다.

만약 클라이언트가 NULL을 사용한다면 어떻게 대응해야 할까?

1. NULL 을 체크한 후 예외를 던진다.

2. NULL 을 무시한다. 인자가 절대 NULL 이 아니라고 가정하고 어떤 대비도 하지 않는다.

   메서드 실행 도중에 NullPointerException이 던져지고 호출자는 자신의 실수를 인지하게 될 것.

중요하지 않은 NULL 확인 로직으로 코드를 오염시켜서는 안된다.

메서드 인자로 절대 NULL을 사용하지 마라. 예외는 없다.

## 3.4 충성스러우면서 불변이거나, 아니면 상수이거나

세상은 가변적이지만, 불변 객체로 세상을 모델링할 수 없는 것은 아니다.

핵심은 객체가 살아있는 동안 상태가 변하지 않는다는 사실이 중요하다.

직관적으로 사람들은 불변 객체의 메서드를 호출할 때마다 상수처럼 매번 동일한 데이터가 반환되리라 기대한다.

이러한 사고방식은 틀렸다. 상수처럼 동작하는 객체는 단지 불변성의 특별한 경우일 뿐이기 때문이다.

불변 객체는 그 이상이다.

결과가 변하기 때문에 상수는 아니지만 객체가 대표하는 엔티티에 충성하기 때문에 불변 객체로 분류될 수 있다.

객체란 실제 엔티티의 대표자이다.

기본적으로 모든 객체는 식별자, 상태, 행동을 포함한다.

불변 객체와 가변 객체의 중요한 차이는 불변 객체에는 식별자가 존재하지 않으며, 절대로 상태를 변경할 수 없다는 것이다.

좀 더 정확하게 말해서 불변 객체의 식별자는 객체의 상태와 완전히 동일하다.

완벽한 객체지향 세계에는 불변 객체만 존재하기 때문에 equals()와 hashCode() 라는 두 메서드가 필요하지 않다.

객체가 대표하는 실제 엔티티와 객체의 상태가 동일한 경우에는 불변 대신 상수라는 용어를 사용하길 권장한다.

상수 객체가 설계하고, 유지보수하고, 이해하기에 더 편하기 때문에 불변 객체보다는 상수 객체를 사용하는 편이 더 낫다.

어떤 종류의 시스템이라도 전체적으로 불변 객체를 이용해서 설계될 수 있고 설계되어야 한다.

## 3.5 절대 getter와 setter를 사용하지 마세요

### 3.5.1 객체 대 자료구조

객체와 자료구조의 차이점은 무엇이고, 자료구조가 OOP에서 해로운 이유는 무엇일까.

struct는 단순한 데이터가방일 뿐이다.

클래스는 다르다. 클래스는 어떤 식으로든 멤버에게 접근하는 것을 허용하지 않는다.

캡슐화, OOP가 지향하는 가장 중요한 설계 원칙 중 하나이다.

자료구조는 투명하지만, 객체는 불투명하다.

자료구조는 글래스 박스이지만, 객체는 블랙 박스이다.

우리는 오직 객체만 상용하고 싶고 자료구조는 절대 사용하고 싶지 않다.

절차적인 세상보다 더 단순한 세상을 창조하기 위해 OOP가 발명되었다는 사실을 기억해라.

객체가 일급 시민이며, 생성자를 통한 객체 초기화가 곧 소프트웨어이다.

절차적인 프로그래밍 스타일을 피해야 한다.

### 3.5.2 좋은 의도, 나쁜 결과

getter와 setter는 캡슐화 원칙을 위반하기 위해 설계되었다.

언어와 IDE 설계자들은 getter와 setter를 이용해서 private 프로퍼티를 감싸는 방식을 권장한다.

getter와 setter를 사용하면 OOP의 캡슐화 원칙을 쉽게 위반할 수 있다는 점이 요점이다.

겉으로는 메서드처럼 보이지만, 실제로는 우리가 데이터에 직접 접근하고 있다는 불쾌한 현실을 가리고 있을 뿐이다.

getter와 setter의 내부 구현과 무관하게 이들은 데이터일 뿐이다. 행동이 아닌 데이터를 표현할 뿐이다.

### 3.5.3 접두사에 관한 모든 것

get과 set이라는 접두사는 이 객체가 진짜 객체가 아니고, 어떤 존중도 받을 가치가 없는 자료구조라는 사실을 명확하게 전달한다.

getDollars()는 데이터 중에 dollars를 찾은 후 반환하세요 라고 이야기하는 것이고,

dolloars()는 얼마나 많은 달러가 필요한가요 라고 묻는 것입니다.

dolloars()는 객체를 데이터의 저장소로 취급하지 않고, 객체를 존중합니다.

결론은 getter와 setter가 OOP에서 끔찍한 안티 패턴이라는 것입니다.

## 3.6 부 ctor 밖에서는 new를 사용하지 마세요

의존성 주입에 관해 이야기해보자.

객체가 필요한 의존성을 직접 생성하는 대신, 우리가 ctor을 통해 의존성을 주입한다.

이와 같이 의존성을 주입하는 것은 좋은 프랙티스이다.

부 ctor을 제외한 어떤 곳에서도 new를 사용하지 말아라.

부 ctor를 제외한 어떤 곳에서도 new를 사용할 수 없도록 금지시킨다면, 객체들은 상호간에 충분히 분리되고 테스트 용이성과 유지보수성을 크게 향상시킬 수 있다.

## 3.7 인트로스펙션과 캐스팅을 피하세요

타입 인트로스펙션과 캐스팅을 사용하고 싶은 유혹에 빠지더라도 절대로 사용해서는 안된다.

이 접근방법은 타입에 따라 객체를 차별하기 때문에 OOP의 기본 사상을 심각하게 훼손시킨다.

런타임에 객체의 타입을 조사하는 것은 클래스 사이의 결합도가 높아지기 때문에 기술적인 관점에서도 좋지 않다.

방문한 객체에 대한 기대를 문서에 명시적으로 기록하지 않은 채로 외부에 노출해버린다.

어떤 클라이언트는 여러분이 기대하는 바를 학습한 후 더 적절한 객체를 제공하겠지만 어떤 클라이언트는 그럴 수 없을 것이다./

instanceof 연산자를 사용하거나 클래스를 캐스팅하는 일은 안티패턴이기 때문에 사용해서는 안된다.

