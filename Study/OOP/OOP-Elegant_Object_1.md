# 1장 출생

## 1.1 -er로 끝나는 이름을 사용하지 마세요.

객체는 자신의 **가시성 범위(scope of visibility)** 안에서 살아간다.

- 객체와 클래스의 차이

  클래스는 객체의 팩토리(factory) 이다. 클래스는 객체를 생성한다.

  이를 클래스가 객체를 인스턴스화한다 라고 표현.

new 를 통해 객체를 생성 가능하다. Java등의 발전된 언어는 delete 지원하지 않는다. c++은 지원함.

클래스를 객체의 능동적인 관리자로 생각해야 한다.

클래스는 객체를 꺼내거나 반환할 수 있는 위치이기 때문에, 클래스를 저장소 또는 웨어하우스라고 불러야 한다.

---

클래스 이름을 짓는 적절한 방법

클래스의 이름은 무엇을 하는지가 아니라 무엇인지에 기반해야 한다.

객체는 그의 역량으로 특정지어야 한다. 속성이 아니라 할 수 있는 일로 설명해야 한다.

객체는 연결장치도 아니고, 절차의 집합이 아니다.

객체는 캡슐화된 데이터의 대표자이다.

따라서 클래스의 이름은 -er로 끝나면 안된다.

---

예) 소수를 찾는 알고리즘 클래스의 이름

- 잘못된: Primer, PrimeFinder, PrimeChooser...
- 올바른: PrimeNumbers

마치 어떤 절차가 안에 있는게 아니라 그냥 소수들의 집합이 있는것과 같이 대하라.

객체는 그 소수들의 집합, 목록 그 자체여야 한다.

---

요약

새로운 클래스에 이름을 붙일 때는 무엇을 하는지가 아니라 무엇인지를 생각해야 한다.

---

## 1.2 생성자 하나를 주 생성자로 만드세요

C++ 에서는 생성자를 ctor라고 부른다.

이 책이 권장하는대로 클래스를 설계한다면, **ctor의 갯수가 메서드의 수보다 많아진다.**

**핵심은 응집도가 높고 견고한 클래스에는 적은 수의 메서드와 상대적으로 더 많은 수의 ctor가 존재한다는 점이다.**

여러 타입을 수용할 수 있도록 오버로딩해서 구현.

하나의 주(primary) ctor 와 여러개의 부(secondary) ctor 로 구분한다.

- 주 ctor: 초기화 로직을 구현
- 부 ctor: 주 ctor를 호출하도록 구현.
- 부 ctor를 먼저 위치시키고 주 ctor를 나중에 위치시킨다.

이 로직의 핵심은

**중복 코드를 방지하고 설계를 더 간결하게 만들기 때문에 유지보수성이 향상된다** 는 점이다.

---

메서드 오버로딩을 지원하지 않는 언어에서는?

인자들을 map에 담아 전달하는 방법.

---

내부 프로퍼티는 오직 한 곳에서만 초기화해야 한다는 핵심 원칙만 따르면 된다.

나머지 부분에서는 단순히 인자를 준비하고, 포메팅하고, 파싱하고, 변환만 해야 한다.

---

복잡성과 중복이라는 두 문제가 해결되었다.

---

## 1.3 생성자에 코드를 넣지 마세요

생성자에서 인자들을 어떻게 다뤄야 할까?

인자에 손대지 말라!

---

진정한 객체지향에서 인스턴스화란 더 작은 객체들을 조합해서 더 큰 객체를 만드는 것을 의미

객체를 생성하는 작업과 객체가 우리를 위해 작업을 하게 만드는 것을 분리

---

성능관점

만약 객체가 생성될때마다 ctor에서 바로 파싱이되면 최적화 못함

파싱 부분 분리 해놓으면 최적화 가능

요청이 있을 때 (on demand)로 파싱하고, 여러번 파싱 안되게 데코레이터(decorator)를 추가해서 최초의 파싱 결과를 캐싱할 수도 있음.

---

객체는 요청을 받을 때만 행동하고 그 전에는 어떤 일도 하지 않아야 한다.

객체들은 좋은 방식으로 매우 게을러야 한다.

가벼운 ctor은 설정하기 쉽고 투명하게 사용할 수 있기 때문에 객체를 더 빠르게 만들 수 있다.

---

# 2. 학습

이번 챕터에서 배우게 될 교훈을 한 문장으로 말한다면

> 객체는 작아야 한다

---

## 2.1 가능하면 적게 캡슐화하세요

복잡성은 직접적으로 유지보수성에 영향을 미친다.

4개 또는 그 이하의 객체를 캡슐화 할 것을 권장.

그 이상이 필요하면 클래스에 문제가 있는 것.

```java
class Cash {
  private Integer digits;
  private Integer cents;
  private String currency;
}
```

위 클래스는 3개의 객체를 캡슐화하고 있다.

이 3개의 객체들이 모여 Cash 클래스의 객체를 식별한다.

위 3개 객체가 같은 값으로 모여 하나의 클래스가 되면 두 객체는 서로 동일하다.

---

상태 없는 객체는 존재해서는 안되고, 상태는 객체의 식별자여야 한다.

---

4개 이상의 좌표는 직관에 위배된다.

우리의 사고방식으로 4개 이상의 요소로 구성된 좌표를 이해하는것은 너무나도 어려움

개념을 트리 형태로 구현해서 4개이하로 유지해야 함.

---

## 2.2 최소한 뭔가는 캡슐화 하세요

또 다른 극단에는 어떤 것도 캡슐화 하지 않는 객체가 존재한ㄷ나.

```java
class Year {
  int read() {
    return System.currentTimeMillis()
      / (1000 * 60 * 60 * 24 * 30 * 12) - 1970;
  }
}
```

Year 클래스의 인스턴스는 어떤 것도 캡슐화 하지 않기 때문에 이 클래스의 모든 객체들은 동일하다.

프로퍼티가 없는 클래스는 객체지향 프로그래밍에서 악명이 높은 정적 메서드와 유사하다.

실행으로부터 인스턴스 생성을 고립시켜야 한다.

오직 ctor에서만 new 연산자를 허용해야 한다.

```java
class Year {
  private Millis millis;
  Year(Millis msec) {
    this.millis = msec;
  }
  int read() {
    return this.millis.read()
      / (1000 * 60 * 60 * 24 * 30 * 12) - 1970;
  }
}
```

무언가는 캡슐화 해야한다.

---

## 2.3 항상 인터페이스를 사용하세요

객체들은 서로를 필요로 하기 때문에 결합한다.

객체 사이의 강한 결합도가 심각한 문제가 된다.

최선을 다해서 객체를 분리해야 한다.

이를 가능케 하는게 인터페이스이다.

----

```java
interface Cash {
  Cash multiply(float factor);
}
```

```java
class DefaultCash implements Cash {
  private int dollars;
  DefaultCash(int dlr) {
    this.dolloars = dlr;
  }
  @Override
  Cash multiply(float factor) {
    return new DefaultCash(this.dolloars * factor);
  }
}
```

```java
class Employee {
  private Cash salary;
}
```

Employee 클래스는 Cash 인터페이스의 구현 방법에 아무런 관심이 없다.

---

클래스 안의 **모든** 퍼블릿 메서드가 인터페이스를 구현하도록 만들어야 한다.

즉 다음과 같이 해서는 안된다.

```java
class Cash {
  public int cents() {
    // 어떤 작업을 수행한다.
  }
}
```

 cents() 메서드는 어떤 것도 오버라이드 하지 않기 떄문에 문제가 있다.

이 설계는 클래스의 사용자(다른 클래스)로 하여금 이 클래스에 강하게 결합되도록 조장한다.

---

**느슨한 결합도**

---

## 2.4 메서드 이름을 신중하게 선택하세요

- 빌더의 이름은 명사로 지어라.
- 조정자의 이름은 동사로 지어라.

---

- 빌더: 뭔가를 만들고 새로운 객체를 반환하는 메서드
- 조정자: 객체로 추상화한 실세계 엔티티를 수정하는 메서드를 조정자라고 함.

---

```java
int pow(int base, int power);
float speed();
Employee employee(int id);
String parsedCell(int x, int y);
```

```java
void save(String content);
void put(String key, Float value);
void remove(Employee emp);
void quicklyPrint(int id);
```

quickly는 단순히 print를 설명하는 것일 뿐이다.

핵심은 print라는 동사.

---

빌더와 조정자 사이에는 어떤 메서드도 존재해서는 안된다.

즉, 뭔가를 조작한 수 반환하거나, 뭔가를 만드는 동시에 조작하는 메서드가 있어서는 안된다.

잘못된 예)

```java
// 저장된 전체 바이트를 반환
int save(String content);
// 조정자이기 때문에 이 이름은 올바르지 않다.
// void를 반환하도록 바꾸거나, bytesSaved()와 같은 이름으로 바꿔야 함.

// map이 변경된 경우 TRUE를 반환
boolean put(String key, Float value);
// 조정자 처럼 동작하지만 빌더처럼 boolean을 반환하기 때문에 동일한 문제 발생
// 아무것도 반환하지 않도록 수정해야 함.
// 안에 success() 메서드 만들어서 성공/실패 여부 반환하는 빌더 포함시켜야 함.

// speed를 저장한 후 이전 값을 반환
float speed(float val);
// 빌더인 동시에 조정자임.
// SaveSpeed 클래스를 추가하고 speed를 저장하는 메서드와 이전 값을 반환하는 메서드를 구현해야 함.
```

getter 와 setter는 동사로 시작하지만, getter는 근본적으로 어떤 값을 반환하는 빌더이다.

따라서 getter에 반대한다.

---

### 2.4.1 빌더는 명사다

어떤 것을 반환하는 메서드의 이름을 동사로 짓는 것은 잘못이다.

제과점에가서

>  브라우니를 요리해 주세요, 커피 한잔 끓여 주세요

하지 않는다.

>  브라우니 주세요, 커피 한잔 주세요 라고 한다.

---

```java
class Bakery {
  Food cookBrownie();
  Drink brewCupOfCoffee(String flavor);
}
```

두 메서드는 실제로는 객체의 메서드가 아니다. 이들은 프로시저이다.

이는 객체지향적인 접근 방법이 아니라 절차적인 접근방법이다.

```java
Food* cook_brownie() {
  // 브라우니를 요리해서
  // 반환한다
}
Drink* brew_cup_of_coffee(char* flavor) {
  // 커피를 끓여서
  // 반환한다
}
```

이 코드에는 제과점이라는 개념이 전혀 드러나 있지 않다.

프로시저에 불과하다.

**객체는 자신의 의무를 수행하는 방법을 알고 있고 존중 받기를 원하는 살아있는 유기체이다.**

객체는 단순히 지시에 따르는 것이 아니라 계약에 기반해 일하고 싶어한다.

---

메서드의 이름을 동사로 지을 때에는 객체에게 무엇을 할 지 를 알려주어야 한다.

객체에게 무엇을 만들라고 요청하는 것은 존중이 없는 방식이다.

무엇을 만들어야 하는지만 요청하고, 만드는 방법은 객체 스스로 결정하도록 해야 한다.

---

다음의 메서드 이름은 모두 잘못지어졌다.

```java
InputStream load(URL url);
String read(File file);
int add(int x, int y);
```

다음과 같이 고쳐야 한다.

```java
InputStream stream(URL url);
String content(File file);
int sum(int x, int y);
```

우리는 객체에게 x와 y를 더하라고(add) 요청하지 않는다.

대신, 두 수의 합(sum)을 계산하고 새로운 객체를 반환해 달라고 요청한다.

---

### 2.4.2 조정자는 동사다

실세계의 엔티티를 조작해야 하는 경우에는, 다음과 같이 객체가 그 작업을 수행하도록 요청한다.

```java
class Pixel {
  void paint(Color color);
}
Pixel center = new Pixel(50, 50);
center.paint(new Color("red"));
```

paint() 메서드는 값을 반환하지 않는다.

우리는 바텐더에게 음악을 틀고 현재의 볼륨 상태를 말해주세요 하지 않는다.

---

오직 빌더만이 값을 반환할 수 있고 이름은 명사이다.

객체가 뭔가를 조정해야 한다면 이름은 동사이고 반환값이 없다.

---

빌더 패턴은 유지보수성이 낮고 응집도가 떨어지는 더 커다란 객체를 만들도록 조장하기 때문에 빌더 패턴에 반대한다.

빌더 패턴을 사용하는 대신 복잡한 객체를 더 작은 객체들로 나눠야 한다.

빌더 패턴을 쓰지 마라.

---

## 2.4.3 빌더와 조정자 혼합하기

파일 내용을 저장하고 저장된 바이트 수를 반환하는 메서드가 있다고 가정

```java
class Document {
  int write(InputStream content);
}
```

이 메서드는 앞서말한 원칙을 위반하고 있음.

메서드 write의 반환 타입을 void로 바꿔야 하지만, 우리는 실제로 저장된 바이트 수를 알 필요가 있음.

하나의 메서드 안에서 너무 복잡한 일을 처리하고 있음.

다음과 같이 리팩토링 하는것을 추천.

```java
class Document {
  OutputPipe output();
}
class OutputPipe {
  void wrtie(InputStream content);
  int bytes();
  long time();
}
```

output() 메서드는 빌더이다.

OOP의 전체 목적은 개념을 고립시켜 복잡성을 낮추는 것이다.

고립시킨 개념이 작을수록 이해하고 유지보수하기도 더 쉬워진다.

이 경우 고립시킨 개념은 '문서에 바이트 쓰기'이다.

---

## 2.4.4 Boolean 값을 결과로 반환하는 경우

Boolean 값을 반환하는 메서드의 이름은 어떻게 짓는 것이 좋을까?

지금까지 원칙에 의하면 isEmpty(), equals(), exists() 다 틀렸다.

그러나 Boolean 값을 반환하는 메서드는 규칙에 있어서 예외적인 경우이다.

빌더에 속하지만, 가독성 측면에서 이름은 **형용사** 로 지어야 한다.

---

메서드를 읽을때는 is를 앞에 붙여서 읽고

실제로는 is를 때고 이름을 지어라.

---

```java
boolean empty(); // is empty
boolean readable(); //is readable
boolean negative(); // is negative
```

---

그러나 다음과 같은 상황에서는 문제가 생긴다.

```java
boolean equals(Object obj); //isEquals?
boolean exists(); //isExists?
// 앞에 is를 붙이면 올바르지 않은 문장이 됨
```

equalTo, present 로 바꾸면 됨.

---

## 2.5 퍼블릭 상수(Public Constant)를 사용하지 마세요

객체들은 어떤 것도 공유해서는 안된다.

대신 독립적이어야 하고 닫혀 있어야 한다.

상수를 이용한 공유 매커니즘은 캡슐화와 객체지향적인 사고 전체를 부정하는 일이다.

결합도가 높아지고 응집도가 낮아진다.

---

### 2.5.1 결합도 증가

```java
class Records {
  void write(Writer out) {
    for (Record rec : this.all) {
      out.write(rec.toString());
      out.write(Constants.EOL); // 여기!
    }
  }
}
```

```java
class Rows {
  void print(PrintStream pnt) [
    for (Row row : this.fetch()) {
      pnt.printf(
      "{%s}", row, Constants.EOL) // 여기!
     );
    }
  ]
}
```

두 클래스는 모두 같은 객체에 의존하고 있으며, 이 의존성은 **하드 코딩** 되어 있다.

의존성을 쉽게 분리할 수 있는 방법이 없다.

---

### 2.5.2 응집도 저하

낮은 응집도는 객체가 자신의 문제를 해결하는데 덜 집중한다는 것을 의미한다.

객체들은 상수를 다루는 방법을 알고 있어야 한다.

객체는 아주 멍청한 상수 위에 자신만의 **의미론** 을 덧붙여야 한다.

---

객체 사이에 데이터를 중복해서는 안된다.

대신, 기능을 공유할 수 있도록 **새로운 클래스** 를 만들어야 한다.

**데이터가 아니라 기능을 공유해야 한다**

---

## 2.6 불변 객체로 만드세요

