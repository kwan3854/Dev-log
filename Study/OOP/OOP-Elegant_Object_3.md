# 4. Retirement 은퇴

## 4.1 절대 NULL을 반환하지 마세요

NULL을 메서드의 인자에 전달하는 것은 객체지향과 절차적인 스타일에서 확실히 좋지 않다.

또한 NULL을 리턴하면, 간단히 말해서 반환하는 객체를 신뢰할 수가 없게 된다.

NULL을 반환하는 객체는 장애를 안고 있기 때문에 특별하게 대우할 필요가 있다.

해당 메서드가 호출될 때마다 항상 NullPointerException 예외가 던져질지 모른다는 사실에 불안할 수 밖에 없다.

객체에 대한 신뢰가 무너졌다는 것이다.

객체는 자신의 행동을 전적으로 책임지고 우리가 어떤 식으로든 간섭하지 않는다.

객체에게 아무런 말도 하지 않은 채 우리 마음대로 예외를 던져서는 안된다.

반환값을 검사하는 방식은 애플리케이션에 대한 신뢰가 부족하다는 명백한 신호이다.

이 또한 유지보수성과 관련이 있다.

코드을 읽을 때 신뢰할 수 있는 메서드 호출이 어떤 것이고 NULL을 반환하는 메서드 호출이 어떤 것인지를 이해하기 위해 더 많은 시간이 필요하기 때문에, 신뢰의 부족은 결과적으로 유지보수성의 심각한 손실로 이어진다.

그렇다면 왜 그렇게 NULL을 반환하는 코드가 흔하고 널리 사용되는 것일까?

설계자들이 JDK를 설계하던 시점에 빠르게 실패하기 원칙을 몰랐기 때문이라고 추측한다.

### 4.1.1 빠르게 실패하기 vs 안전하게 실패하기

소프트웨어 견고성과 실패 탄력회복성 관련해서 상반되는 두 가지 철학이 존재한다.

- 빠르게 실패하기

  일단 문제가 발생하면 곧바로 실행을 중단하고 최대한 빨리 예외를 던진다.

  저자는 이를 열렬하게 지지한다.

- 안전하게 실패하기

  어떠한 상황에서도 소프트웨어가 계속 실행될 수 있도록 최대한 많은 노력을 기울이는 방법.

  저자는 이를 강하게 반대한다.

에러를 발견한 즉시 보고하는 경우에만 안전성과 견고함을 얻을 수 있다.

더 빠르게 문제를 찾을수록 더 빠르게 실패하고, 결과적으로 전체적인 품질이 향상된다.

반대로 더 오래 숨길수록 문제는 더 커진다.

### 4.1.2 NULL의 대안

- 첫 번째 방법은 메서드를 두 개로 나누는 것이다.

  - 첫 번째 메서드는 객체의 존재를 확인한다.

  - 두 번째 메서드는 객체를 반환한다.

    아무것도 찾지 못한 경우 두 번째 메서드는 예외를 던진다.

  - 요청을 두 번 전송하기 때문에 비효율적

- 두 번째 방법은 NULL을 반환하거나 예외를 던지는 대신 객체 컬렉션을 반환

- 세 번째 방법은 널 객체(null object) 디자인 패턴

  - 원하는 객체를 발견하지 못할 경우, 겉으로 보기에는 원래의 객체처럼 보이지만 실제로는 다르게 행동하는 객체를 반환.
  - 널 객체는 일부 작업은 정상적으로 처리하지만, 나머지 작업은 처리하지 않음.
  - 제한된 상황에서만 사용 가능하다는 단점이 있다.
  - 반환된 객체의 타입을 동일하게 유지해야 한다.

## 4.2 체크 예외 (chekced exception) 만 던지세요

모든 예외는 체크 예외여야 한다.

다양한 예외 타입을 만드는 것도 좋지 않은 생각이다.

대부분의 언어들에서 언체크 예외만 사용할 수 있다.

하지만 미래에 등장할 새로운 OOP 언어들은 기존의 언어들보다 훨씬 더 엄격하고, 예외에 기반한 에러 처리에 더 많은 관심을 가질 것으로 기대한다.

- 체크 예외는 항상 가시적이다.

  이 메서드를 사용하기 위해서는 안전하지 않다고 선언하거나, 아니면 예외를 잡아서 해결해야 한다.

- 언체크 예외는 무시할 수 있다.

  예외를 잡지 않아도 무방하다.

  언체크 예외를 던지면 누군가 예외를 잡기 전까지 자동으로 상위로 전파된다.

  하지만 예외 처리를 강요하지 않는다.

### 4.2.1 꼭 필요한 경우가 아니라면 예외를 잡지 마세요

모든 예외를 잡아서 메서드를 안전하게 만들지, 아니면 상위로 문제를 전파할지를 명확하게 선택해야 한다.

가능하면 예외를 더 높은 레벨로 전파해라.

모든 catch 문에는 납득할 수 있는 이유가 있어야 한다.

다시말해, 반드시 예외를 잡아야 하는 이유가 있거나 다른 선택의 여지가 없는 경우가 아니라면 예외를 잡아서는 안된다.

이상적인 설계에서는 애플리케이션의 각 진입점 별로 오직 하나의 catch 문만 존재해야 한다.

어떻게든 문제가 생겨도 프로그램이 계속 작동하게 예외를 잡아서 사용하는 방식,

이를 흐름 제어를 위한 예외 사용이라고 부른다.

이 방식을 사용하면, 실제로 해당 부분에 오류가 있었다는 신호를 알아채기까지 디버깅에 몇 시간이 소요될지 알 수 없다.

예외를 다시 던지지 않고 구조할 때마다 안전하게 실패하기라는 사고방식으로 여러분 자신을 밀어내고 있는 것이다.

### 4.2.2 항상 예외를 체이닝하세요

예외 되던지기(rethrowing)에 대해 살펴보자.

예외를 잡은 즉시 새로운 예외를 던져라. 이와 같은 예외 체이닝은 훌륭한 프랙티스이다.

원래의 문제를 새로운 문제로 대체함으로써 문제가 발생했다는 사실을 무시하지 않는다.

체이닝이 여러 번 발생하면, 위로 전파되는 예외는 내부에 다른 비눗방울을 포함한 더 커다란 비눗방울처럼 보이게 된다.

마지막 catch문은 비눗방을을 터트린 후 그 안에 포함된 모든 비눗방울을 꺼낸다.

여기에서핵심은 문제를 발생시켰던 낮은 수준의 근본 원인을 소프트웨어의 더 높은 수준으로 이동시켰다는 것이다.

**항상 예외를 체이닝하고 절대로 원래 예외를 무시하지 말아라.**

예외 체이닝은 의미론적으로 문제와 관련된 문맥을 풍부하게 만들기 위해 필요하다.

여러 예외들을 내부에 담고 있는 일련의 예외 체인을 사용하는 편이 좋다.

이상적으로 각각의 메서드는 발생할 수 있는 모든 예외를 잡은 후, 예외를 체이닝해서 다시 던져야 한다.

### 4.2.3 단 한번만 복구하세요

예외 후 복구라는 개념에 대해 살펴보자.

일단, 예외 후 복구는 빠르게 실패하기 라는 관점에서는 있을 수 없다.

그럼에도 불구하고 살펴보면,

어떤 소프트웨어이든 복구에 적합한 몇 개의 장소가 존재한다.

그 이외의 장소에서는 예외를 잡아서 다시 던지거나, 또는 절대로 예외를 잡지 말아야 한다.

**첫 번째 방법이 더 좋다. 항상 예외를 잡고, 체이닝하고, 다시 던져라. 그리고 최상위 수준에서 오직 한번만 복구해라.**

### 4.2.4 관점-지향 프로그래밍을 사용하세요

가끔씩은 실패한 오퍼레이션을 재시도할 필요가 있다.

한 가지 해결 방법이 있기는 하다.

관점지향 프로그래밍이다. (AOP)

AOP는 단순하면서도 강력한 프로그래밍 패러다임으로 OOP와도 궁합이 잘 맞는다.

```java
@RetryOnFailure(attempts = 3)
public String content() throws IOException {
  return http();
}
```

OOP 에서 흔하게 볼 수 있는 성급한 예외 복구 방법이 매우 안 좋은 아이디어이며 다른 기법으로도 충분히 대체가 가능하다.

### 4.2.5 하나의 예외 타입만으로도 충분하다.

예외 타입이 중복기능(redundant feature)인 이유를 이해해 보자.

우리는 흐름 제어를 위해서는 절대로 예외를 사용하지 않기로 했다.

그렇다면 잡은 예외의 실제 타입에 대해서는 신경 쓸 필요가 없다. 어차피 다시 던질 것이기 때문이다.

## 4.3 final 이나 abstract 이거나

상속보다 캡슐화를 쓰자.

**상속이 해로운 이유**

- 상속은 객체들의 관계를 너무 복잡하게 만든다.

  클래스를 쌓아 만든 높이가 5단계를 넘어가는 순간부터는 이해하기 어려워진다.

- 근본적인 원인은 상속 그 자체가 아니라 가상 메서드이다.

**해결법**

- 클래스와 메서드를 final 이나 abstract 둘 중 하나로만 제한하면 된다.
  - final 이면 상속을 받을 수 없다.
  - abstract 라면 혼란스럽지 않다.

**클래스가 가질 수 있는 신분 세 가지**

- final
  - 사용자 관점에서 블랙박스
  - 독립적, 자신이 어떻게 행동해야 하는지 알고 있고, 도움이 필요 없음.
  - final 클래스 안의 어떤 메서드도 오버라이딩할 수 없음.
- abstract
  - 글래스 박스
  - 스스로 행동할 수 없음. 누군가의 도움 필요.
  - 불완전, 일부 요소가 누락
  - 아직 클래스가 아님 (제대로 된 클래스를 생성하기 위한 원재료)
  - 내부의 메서드를 오버라이딩 할 수 있지만 다른 메서드는 모두 final
- 둘 중 어느 쪽도 아님
  - 강력하게 반대하는 상태
  - 블랙 박스와 글래스 박스 둘 중 어느 쪽도 될 수 있음
  - 혼란스러움

---

만약 모든 클래스가 final  이라면 오로지 캡슐화만을 이용할 수 있다.

만약 모든 클래스를 final 이나 abstract로 만든다면 상속을 사용할 일이 거의 없을 것이다.

가끔씩은 상속을 사용하게 될 것이다.

- **언제 상속이 적절한가?**
  - 클래스의 행동을 확장하지 않고 정제할 때 이다.
  - OOP에서는 어떤 것도 확장할 수 없어야 한다.

## 4.4 RAII를 사용하세요

리소스 획득이 초기화(RAII) 라는 개념에 대해 설명한다.

RAII는 C++에 존재하는 매우 강력한 기법이지만 가비지 컬렉션을 이용해서 객체를 제거하는 Java에서는 사라진 개념이다.

RAII를 사용할 것을 적극 추천한다.