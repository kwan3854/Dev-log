

# Limited Direct Execution (제한적 직접 실행 원리)

**핵심 질문: 제어를 유지하면서 효과적으로 CPU를 가상화하는 방법**

**CPU 가상화** 를 통해 운영체제는 여러 작업들이 동시에 실행되는 것처럼 물리적인 CPU를 공유한다.

이를 위해 CPU 시간을 나누어 쓰게 된다. 그러나 이 방법은 몇가지 문제를 가져온다.

1. **성능 저하** (performance)

   > 시스템에 심한 오버헤드를 주지 않으면서 구현해야 한다.

2. **제어 문제** (control)

   > CPU에 대한 통제를 유지하면서 프로세스를 동작해야 한다.

특히 운영체제 입장에서는 제어권을 빼앗기는 것은 치명적이다.

---

## 1. 기본 원리: 제한적 직접 실행

운영체제 개발자들은 프로그램의 빠른 실행을 위해 **제한적 직접 실행 (Limited Direct Execution)** 이라는 기법을 개발했다.

**직접 실행** 이라는 의미는 말 그대로 프로그램을 CPU 상에서 직접 실행하는 것을 의미한다.

아래 표는 기본적인 직접 실행 방식을 표현하고 있다.

| 운영체제                              | 프로그램                             |
| ------------------------------------- | :----------------------------------- |
| 프로세스 목록의 항목을 생성           | -                                    |
| 프로그램 메모리 할당                  | -                                    |
| 메모리에 프로그램 탑재                | -                                    |
| **argc** / **argv** 를 위한 스택 셋업 | -                                    |
| 레지스터 내용 삭제                    | -                                    |
| **call main ()** 실행                 | -                                    |
| -                                     | **main ()** 실행                     |
| -                                     | **main** 에서 **return** 명령어 실행 |
| 프로세스 메모리 반환                  | -                                    |
| 프로세스 목록에서 항목 제거           | -                                    |

> 이 방법은 아무 제한이 없다.
>
> 이 점이 CPU 가상화에 있어 몇 가지 문제점을 일으킨다.
>
> 1. 프로그램이 운영체제가 원치 않는 일을 한다면?
> 2. 프로세스 실행 시, 운영체제는 어떤 방법으로 기존 프로그램의 실행을 중단하고 다음 프로그램으로 전환? (시분할)

이러한 문제들을 해결하기 위해 **제한적 직접 실행** 이라는 용어에서 '제한적'이라는 단어가 생겨난 것이다.

프로그램 실행에 제한이 없는 운영체제는 아무것도 제어할 수 없고, 단순한 라이브러리와 같다.

---

## 2. 문제점 1: 제한된 연산

**핵심 질문: 제한 연산을 수행하는 방법**

> 만약 프로세스가 운영체제가 제한한 연산을 수행해야 한다면?
>
> 예) I/O request, 더 많은 시스템 리소스 요청(GPU, 메모리 등)

이를 위해 **사용자 모드 (user mode)** 와 **커널 모드 (kernel mode)** 가 생겨났다.

- **사용자 모드**

  > 프로세스가 사용자 모드에 있으면 할 수 있는 일이 제한된다.
  >
  > 제한된 일을 하려고 하면 프로세서가 예외를 발생시키고, 운영체제는 해당 프로세스를 제거한다.

- **커널 모드**

  > 운영체제의 중요한 코드들이 실생된다. 특수한 명령어를 포함한 모든 원하는 작업을 수행 가능하다.

만약 사용자 프로세스가 디스크 읽기 같은 특권 명령어를 실행해야 할때는?

**시스템 콜** 을 이용해서 접근한다. (마치 은행금고에 직접 들어가서 돈을 넣고 꺼내고 하는게 아니라, 은행원을 통해 하는 것 처럼.)

- **시스템 콜**

  > 대부분의 운영체제는 수백개의 시스템 콜을 제공한다.
  >
  > 시스템 콜이 작동하는 과정은 다음과 같다.
  >
  > 1. 시스템 콜을 실행하기 위해 프로그램은 **trap** 특수 명령어를 실행한다.
  > 2. **trap** 은 커널 안으로 분기하는 동시에 특권 수준을 **커널 모드** 로 상향 조정한다.
  > 3. **커널 모드** 로 진입하면 운영체제는 모든 명령어를 수행 할 수 있고, 이를 통해 프로세스가 요청한 작업을 처리할 수 있다.
  > 4. 작업이 완료되면, 운영체제는 **return-from-trap** 특수 명령어를 호출한다.
  > 5. **return-from-trap** 은 특권 수준을 **사용자 모드** 로 다시 하향 조정하면서 호출한 사용자 프로그램으로 리턴한다.

**return-from-trap** 할때 어떻게 사용자 프로그램으로 돌아갈까?

>  **trap** 명령어가 실행 될 때, 호출한 프로세스의 레지스터들을 각 프로세스의 **커널 스택(kernel stack)** 에 저장한다.
>
> 나중에 **return-from-trap** 명령어가 저장된 레지스터 값들을 스택에서 **pop** 하여 사용자모드 프로그램을 다시 실행한다.

**trap** 이 운영체제 코드 어디를 실행할지 어떻게 알까?

> 호출한 프로세서는 커널 내부의 원하는 지점을 특정할 수 없다. (보안상 위험하기 때문)
>
> 커널은 부팅 시에 **트랩 테이블(trap table)** 을 만들고 이를 이용하여 시스템을 통제한다.
>
> 운영체제는 초기작업으로 하드웨어에게 예외가 생겼을 때 어떤 코드를 실행할 지 알려준다.
>
> 운영체제는 특정 명령어를 사용하여 하드웨어에게 **트랩 핸들러(trap handler)** 의 위치를 알려준다
>
> 하드웨어는 이 위치를 기억하고 있기 때문에 예외가 일어났을 때 어디로 분기할 지 알 수 있다.

위 상황을 인지 한 후 다시 보는 시스템콜의 과정

1. 모든 시스템 콜은 자신의 고유 번호를 갖는다.
2. 사용자 프로그램은 원하는 시스템 콜을 호출하기 위해, 해당 시스템 콜 번호를 레지스터 또는 스택의 지정된 위치에 저장한다.
3. **trap** 명령어를 호출한다. (이 작업은 라이브러리가 수행)
4. **trap 핸들러** 가 실행된다. (trap 핸들러는 운영체제의 일부)
5. 운영체제는 시스템 콜 번호를 읽어 사용자가 명시한 번호가 유효한 시스템 콜에 해당하는지 확인한다. (음수 값인지 등을 확인)
6. 유효한 번호라고 판단되면 해당 코드로 이동하여 실행한다. (시스템 콜 코드의 위치는 운영체제만 안다.)

이를 음식점에서 메뉴판을 보고 주문을 하는것에 비유하여 이해하면 쉽다.

> 1. 모든 음식은 메뉴 번호를 가지고 있다.
> 2. 손님은 원하는 음식을 주문하기 위해, 점원으로부터 메뉴판을 받는다. (메뉴판은 가게에 들어올때 하나씩 받는다.)
> 3. 메뉴판을 보고 메뉴를 골라 점원을 부른다. (점원은 고객이 정한 메뉴를 주방에 전한다.)
> 4. 주방장이 점원으로부터 주문을 듣는다. (봉골레 파스타 하나~)
> 5. 주방장은 그 메뉴가 메뉴판에 있는 유효한 메뉴인지 확인한다. (메뉴판에 없는 메뉴를 주문하는 개념없는 손님은 내쫒는다.)
> 6. 정상적인 주문인게 확인되면 요리를 시작한다. (주방에는 요리사만 들어갈 수 있다.)

| 운영체제 @부트 (커널 모드) | 하드웨어                          |      |
| -------------------------- | --------------------------------- | ---- |
| 트랩 테이블을 초기화한다.  |                                   |      |
|                            | syscall 핸들러의 주소를 기억한다. |      |

| 운영체제 @실행 (커널 모드)            | 하드웨어                                   | 프로그램 (사용자 모드)      |
| ------------------------------------- | ------------------------------------------ | --------------------------- |
| 프로세스 목록에 항목을 추가한다.      |                                            |                             |
| 프로그램을 위한 메모리를 할당한다.    |                                            |                             |
| 프로그램을 메모리에 탑재한다.         |                                            |                             |
| **argv** 를 사용자 스택에 저장한다.   |                                            |                             |
| 레지스터와 PC를 커널 스택에 저장한다. |                                            |                             |
| **return-from-trap**                  |                                            |                             |
|                                       | **커널 스택** 으로부터 레지스터를 복원한다 |                             |
|                                       | **사용자 모드** 로 이동한다.               |                             |
|                                       | main으로 분기한다.                         |                             |
|                                       |                                            | main() 을 실행한다.         |
|                                       |                                            | ...                         |
|                                       |                                            | **시스템 콜** 을 호출한다   |
|                                       |                                            | 운영체제로 **trap** 한다    |
|                                       | 레지스터를 커널 스택에 저장한다.           |                             |
|                                       | 커널 모드로 이동한다.                      |                             |
|                                       | **trap handler** 로 분기한다.              |                             |
| **trap** 을 처리한다.                 |                                            |                             |
| syscall의 임무를 수행한다.            |                                            |                             |
| **return-from-trap**                  |                                            |                             |
|                                       | 커널 스택으로부터 레지스터를 복원한다.     |                             |
|                                       | **사용자 모드** 로 이동한다.               |                             |
|                                       | 트랩 이후의 PC로 분기한다.                 |                             |
|                                       |                                            | main에서 리턴한다.          |
|                                       |                                            | **trap** (exit() 을 통하여) |
| 프로세스의 메모리를 반환한다.         |                                            |                             |
| 프로세스 목록에서 제거한다.           |                                            |                             |

**return-from-trap** 할때 **하드웨어**에서 레지스터 복원과 사용자 모드로의 이동을 **동시에** 한다.

왜? 만약 소프트웨어적으로 처리한다면?

1. 레지스터 복원 먼저, 사용자 모드로 이동 -> 유저 프로그램이 레지스터 복원을 위해 커널영역에 접근가능해진다. (보안문제 발생!)
2. 사용자 모드로 이동 후, 레지스터 복원 -> 사용자모드로 이동한 프로그램은 커널영역에 있는 레지스터 정보를 읽지 못해 레지스터를 복원하지 못한다.

---

## 3. 문제점 2: 프로세스 간 전환

**핵심 질문: CPU를 어떻게 다시 획득할 수 있는가?**

> 운영체제는 어떻게 CPU를 다시 획득하여 프로세스를 전환할 수 있는가?

프로세스 간 전환은 간단해야 한다.

### 3.1 협조방식, 그리고 비협조 방식.

- 협조 방식 (Cooperative Approach): 시스템 콜 호출시 까지 대기

  > 각 사용자 프로세스가 비정상적인 행동을 하지 않을 것이라고 믿는다.
  >
  > CPU를 장기간 사용해야하는 프로세스들은 다른 프로세스들이 CPU를 사용할 수 있도록 주기적으로 CPU를 반납할 것이라 믿는다. (꿈과 같은 이야기이다.)
  >
  > **프로세스는 어떻게 CPU를 반납하는가?**
  >
  > > 응용 프로세스가 어떻게 운영체제에게 제어권을 넘겨주는가가 핵심이다.
  > >
  > > 대부분의 프로세스는 시스템 콜을 자주 호출한다.
  > >
  > > 시스템 콜을 호출하면 자연스럽게 운영체제에게 제어권이 넘어간다.
  > >
  > > 협조방식을 사용하는 운영체제는 **yield** 시스템 콜을 제공한다.
  > >
  > > **yield** 는 운영체제에게 제어권을 넘겨서 운영체제가 다른 프로세스에게 CPU를 할당할 기회를 준다.
  > >
  > > 응용 프로그램이 비정상적인 행위를 하면 **trap** 이 일어나서 다시 운영체제에게 제어권이 넘어가고 운영체제는 해당 프로세스를 종료할 수 있다.
  > >
  > > 만약 무한루프에 빠지면? 문제가 발생한다.

- 비협조 방식 (Non-Cooperative Approach): 운영체제가 제어권 확보

  > **핵심질문: 협조 없이 제어를 얻는 방법**
  >
  > 만약 프로세스가 시스템 콜을 호출하지 않는데도 운영체제가 제어권을 얻고 싶다면?
  >
  > > **하드웨어** 의 도움을 받으면 된다.
  > >
  > > ~~과거에는 재부팅이라는 강력한 방법을 사용했다!~~  실제 과거 초기버전의 맥은 이 방식을 사용했다. [유튜브 영상 링크](https://youtu.be/7B2PIVSWtJA?t=330)
  > >
  > > (실제로 재부팅은 단순히 멍청한 방법이 아닌 매우 유용한 방법임이 입증되었다. 하지만 이 방법 말고는?)
  > >
  > > **타이머 인터럽트 (timer interrupt)** 는 타이머 하드웨어를 프로그래밍 해서 수 밀리초마다 인터럽트 신호를 발생시키게 할 수 있다.
  > >
  > > **인터럽트** 가 발생하면 운영체제는 현재 수행 중인 프로세스를 중단시키고 해당 인터럽트에 대한 **인터럽트 핸들러 (interrupt handler)** 를 실행한다.
  > >
  > > **인터럽트 핸들러** 는 운영체제의 일부분이고, 따라서 자연스럽게 제어권이 운영체제에게 넘어간다.
  >
  > **운영체제는 타이머 인터럽트 발생 시 실행해야 하는 코드의 주소를 기록해두어야 한다.**
  >
  > > 운영체제는 각 인터럽트에 대해, 인터럽트 핸들러의 위치를 테이블 형태로 메모리에 초기화 시킨다.
  >
  > 인터럽트 발생 시, 시스템 콜 호출과 동일하게 실행 중이던 프로그램의 상태를 저장하고, 추후 **return-from-trap** 명령어를 통해 프로그램이 다시 시작된다. 이 과정은 위에 적었던 것처럼 하드웨어적으로 실행된다.

### 3.2 문맥의 저장과 복원

**핵심키워드: 스케줄러(scheduler), 문맥교환(context switch)**

- 스케줄러

  > 어떤 형식으로든 운영체제가 다시 제어건을 획득하면 현재 실행중인 프로세스를 계속 실행 할 지, 다른 프로세스로 전환 할지 결졍해야 한다. 이 결정이 운영체제의 **스케줄러** 라는 부분에 의해 내려진다.
  >
  > 스케줄링 정책에 대해서는 나중에 다룬다.

- 문맥교환

  >운영체제가 다른 프로세스로 전환하기로 결정하면 운영체제는 **문맥교환** 이라는 코드를 실행한다.
  >
  >문맥교환은 현재 실행 중인 프로세스의 레지스터 값들을 커널 스택 같은 곳에 저장하고, 새로 실행될 프로세스의 커널 스택으로부터 레지스터 값을 복원하는 것이다.

아래의 표는 타이머 인터럽트를 이용한 **제한적 직접 실행 방식 (Limited Direct Execution)** 의 동작 과정을 보여준다.

문맥교환 과정을 중점적으로 살펴보자.

| 운영체제 @부트 (커널 모드)  | 하드웨어                                         |      |
| --------------------------- | ------------------------------------------------ | ---- |
| 트랩 테이블을 초기화 한다.  |                                                  |      |
|                             | syscall 핸들러, 타이머 핸들러의 주소를 기억한다. |      |
| 인터럽트 타이머를 시작한다. |                                                  |      |
|                             | 타이머를 시작시킨다.                             |      |
|                             | X msec 지난 후 CPU를 인터럽트한다.               |      |

| 운영체제 @실행 (커널 모드)              | 하드웨어                             | 프로그램 (사용자 모드) |
| --------------------------------------- | ------------------------------------ | ---------------------- |
|                                         |                                      | 프로세스 A             |
|                                         |                                      | ...                    |
|                                         | **타이머 인터럽트**                  |                        |
|                                         | A의 레지스터를 A의 커널 스택에 저장. |                        |
|                                         | 커널 모드로 이동                     |                        |
|                                         | 트랩 핸들러로 분기                   |                        |
| 트램을 처리한다.                        |                                      |                        |
| switch () 루틴 호출                     |                                      |                        |
| A의 레지스터를 A의 proc 구조에 저장     |                                      |                        |
| B의 proc 구조로부터 B의 레지스터를 복원 |                                      |                        |
| B의 커널 스택으로 전환                  |                                      |                        |
| **return-from-trap** (B 프로세스로)     |                                      |                        |
|                                         | B의 커널 스택을 B의 레지스터로 저장  |                        |
|                                         | 사용자 모드로 이동                   |                        |
|                                         | B의 PC로 분기                        |                        |
|                                         |                                      | 프로세스 B             |
|                                         |                                      | ...                    |

---

## 4. 병행실행으로 인한 문제 (Concurrency Problem)

만약 시스템 콜을 처리하는 도중에 타이머 인터럽트가 발생하면?

하나의 인터럽트를 처리하고 있을 떄 다른 인터럽트가 발생하면?

> 이런 경우 커널에서 처리하기 더 어려워지는거 아닌가?

이것이 **병행성** 에 관한 것이다.

- 간단한 해법은 **인터럽트** 를 처리하는 동안에는 **인터럽트를 불능화** 하는 것이다.

  > 손실되는 인터럽트가 생길 수 있다. 여러모로 바람직하지 않은 방법이다.

- 운영체제에서 다양한 **락(lock)** 기법을 사용한다.

  > 커널 내부의 자료구조에 동시에 접근되는것을 방지하기 위해 락으로 내부 자료구조를 보호한다.
  >
  > 덕분에 내부에서 다수의 작업들이 동시에 진행되는 것이 가능하다.
  >
  > 추후 병행성 부분에서 자세히 다루지만, 락 기법으로 인해 운영체제가 매우 복잡해질 수 있고, 많은 버그가 발생한다. 

