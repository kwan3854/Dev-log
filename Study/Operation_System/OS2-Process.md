# Process

**핵심질문: CPU가 여러 개 존재한다는 환상을 어떻게 제공하는가?**

**답: 가상화**

> 시분할, 공간분할, 스케쥴링



## 1. 프로세스란?

> 프로세스란 보이지 않는 개념이다.
>
> 프로세스는 code+state 의 개념이다.



## 2. 프로세스 API

아래의 API들은 모든 현대 운영체제에서 제공된다.

- 생성 (Create)

  > 새로운 프로세스를 생성

- 제거 (Destroy)

  > 프로세스를 강제로 종료하는 수단

- 대기 (Wait)

  > 때론 어떤 프로세스의 실행 중지를 기다릴 필요가 있다. 다양한 종류의 대기 인터페이스가 제공된다.

- 각종 제어 (Miscellaneous Control)

  > 프로세스의 일시정지, 재개 등의 다양한 기능을 제공

- 상태 (Status)

  > 프로세스의 상태 정보를 얻어내는 인터페이스. 얼마 동안 실행되었는지, 어떤 상태인지 등.



## 3. 프로세스 생성

1. 프로그램 코드를 프로세스의 메모리(address space)에 로드한다.

   > 과거의 운영체제들은 프로그램 실행 전에 한번에 코드와 데이터를 모두 메모리에 로드했다.
   >
   > 현대의 운영체제들은 프로그램을 실행하면서 코드나 데이터가 필요할 때 필요한 부분만 로드한다.
   >
   > 이를 위해서는 **paging** 과 **swapping** 기법을 이해해야한다. 추후 메모리 가상화에서 자세히 설명.

2. 프로그램의 스택이 할당된다.

   > C언어의 경우, 지역변수, 함수파라미터, 리턴주소 등을 저장하기 위해 **stack**을 사용한다.
   >
   > **main()** 함수의 파라미터인 **argc** 와 **argv**를 사용하여 **stack**을 초기화 한다.

3. 프로그램의 힙 영역이 생성된다.

   > 힙은 동적으로 할당된 데이터를 저장하기 위해 사용된다.
   >
   > **malloc()** 으로 필요한 공간 요청, **free()** 로 사용했던 공간을 반환한다.
   >
   > 참고: 실제 운영체제의 커널 코드 등에서는 **malloc()**함수를 잘 사용하지 않고 자체 정의 함수등을 사용한다.
   >
   > **malloc()** 함수의 오버헤드가 너무 크기 때문이다.

4. OS가 입출력 관련 초기화 작업을 수행한다.

   > **UNIX**는 **STDIN**, **STDOUT**, **STDERR** 장치에 해당하는 세 개의 **file descriptor**를 갖는다.
   >
   > 이 **file descriptor**를 사용해 프로그램은 터미널로부터 입력을 읽고 화면에 출력을 프린트 작업을 쉽게 할 수 있다.
   >
   > 입출력, file descriptor 에 관해서는 영속성에관한 부분에서 더 자세히 설명.

5. 프로그램을 entry point (main 함수) 부터 실행한다.

   > 프로그램의 시작 지점인 **main()** 함수 루틴으로 분기함으로써, 운영체제는 CPU를 새로 생성된 프로세스에 넘기고, 프로그램이 실행된다.



## 4. 프로세스의 상태 (state)

프로세스 상태를 단순화하면 다음 세 상태가 있다.

- 실행 (Running)

  > 프로세스는 명령어를 실행하고 있다.

- 준비 (Ready)

  > 프로세스는 실행될 준비가 되어있지만, OS가 다른 프로세스를 실행하고 있거나 하는 등의 이유로 대기중이다.

- 대기 (Blocked)

  > 프로세스가 다른 사건을 기다리는 동안 프로세스의 수행을 중단시키는 연산.
  >
  > CPU를 줘도 지금 일 할 수 있는 상태가 아닌 프로세스이다.
  >
  > 예) 프로세스가 디스크에 입출력 요청을 했을 때, 10초에 한번 실행되는 프로세스 등.



> 예) 프로세스는 운영체제의 스케줄링 정책에 따라 스케줄되면 **준비** 상태에서 **실행** 상태가 된다.
>
> **실행** 상태에서 입출력 요청을 하면, **대기** 상태가 된다.
>
> **대기** 상태에서 입출력이 완료되면 다시 **준비** 상태가 된다.
>
> **준비** 상태에서 다시 프로세스는 운영체제의 스케줄링을 기다린다.



만약 **프로세스0**가 입출력요청으로 인해 **대기** 상태가 되면, 놀고있는 CPU를

그 동안 새롭게 **프로세스1**을 스케줄링해서 **실행** 하는것이 반드시 옳을까?

> 운영체제는 스케줄러를 통해 이를 결정하는데, 이후 자세히 다룬다.



## 5. 자료구조 (Data Structures)

운영체제도 일종의 프로그램이다. 운영체제도 다른 프로그램과 마찬가지로 다양한 정보를 유지하기 위한 자료구조를 가지고 있다.

예를들어 준비 상태를 위한 자료구조 프로세스 리스트가 있고, 마찬가지로 실행, 대기 상태를 위한 자료구조도 있다.



- 레지스터 문맥 (register context) 자료구조

  > 프로세스가 중단되었을 때 해당 프로세스의 레지스터 값들을 저장.
  >
  > 후에 이 레지스터 값들을 복원해서 운영체제는 프로세스 실행을 재개.
  >
  > 이를 **문맥 교환 (context switch)** 라고 한다. 추후 자세히 설명.



**실행**, **준비**, **대기** 외에 다른 상태들도 존재한다.

- **초기(initial)** 상태

  > 프로세스가 완전히 생성되기 전까지의 상태.

- **최종(final)** 상태 ==  **좀비(zombie)** 상태

  > 프로세스는 종료되었지만 해당 프로세스가 사용하던 각종 자원이 아직 완전히 반납되지 않은 상태.
  >
  > UNIX 기반 시스템에서는 **좀비(zombie)** 라고 부른다.
  >
  > 보통 하나의 프로세스가 다른 프로세스가 성공적으로 실행을 마쳤는지 파악하는데 유용하게 사용된다.
  >
  > > 예) **부모(parent)** 프로세스가 **자식(child)** 프로세스 실행 마쳤는지 확인할 때.
  > >
  > > **부모** 프로세스는 **자식** 프로세스의 종료를 대기하는 **시스템 콜**( 예, **wait()** )을 호출한다.



xv6 코드를 통해 보면



프로세스를 중단하고 이후 재개하기 위해 저장하고 복원하는 레지스터.

```c
struct context
{
  int eip;
  int esp;
  int ebx;
  int ecx;
  int edx;
  int esi;
  int edi;
  int ebp;
};
```



가능한 프로세스 상태.

```c
enum proc_state { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
```



레지스터 문맥과 상태를 포함하여 각 프로세스에 대하여 xv6가 추적하는 정보.

```c
struct proc
{
  char *mem;										// 프로세스 메모리 시작주소
  uint sz;											// 프로세스 메모리의 크기
  char *kstack;									// 이 프로세스의 커널 스택의 바닥 구조
  enum proc_state state;				// 프로세스 상태
  int pid;											// 프로세스 ID
  struct proc *parent;					// 부모 프로세스
  void *chan;										// 0이 아니면, chan에서 수면
  int killed;										// 0이 아니면 종료됨
  struct file *ofile[NOFILE];		// 열린 파일
  struct inode *cwd;						// 현재 디렉터리
  struct context context;				// 프로세스를 실행시키려면 여기로 교환
  struct trapframe *tf;					// 현재 인터럽트에 해당하는 트랩 프레임
};
```

>process list (process control block, 즉 PCB 가 링크드 리스트처럼 서로 연결된 구조)의 PCB가 xv6에서는 struct proc의 형태로 구현되어 있다.
>
>PCB == Process Descriptor == struct proc 라고 생각하면 된다. (리눅스에서는 task_struct 이다)



## 6. 프로세스 API 의 실제 코드 구현

핵심질문: 프로세스를 생성하고 제어하는 법.

> 프로세스를 생성하고 제어하려면 운영체제가 어떤 인터페이스를 제공해야 하는가?
>
> 유용성, 편리성, 성능을 위해서는 어떻게 인터페이스를 설계해야 하는가?



### 6.1 fork ()

프로세스 생성에 fork() 시스템 콜이 사용된다.

> parent 에는 자식의 PID를 리턴.
>
> 자식에게는 0이 리턴.

