# Free Space Management

**핵심 질문: 빈 공간을 어떻게 관리하는가**

> 가변 크기의 요구를 충족시켜야 할 때, 빈 공간은 어떻게 관리되어야 하는가? 단편화를 최소화하기 위해 어떤 전략을 사용할 수 있는가? 여러 대안들의 시간과 공간의 오버헤드는 어떻게 되는가?

**페이징** 을 배우기 전에, 메모리 관리 시스템의 근본적인 측면에 대해 논의한다.

빈 공간 관리가 어려워지는 경우는?

관리하는 빈 공간이 가변-크기인 경우이다.

사용자가 malloc, free 를 사용하거나, 세그멘테이션으로 물리 메모리를 관리하는 운영체제에서 발생한다.

둘 중 어느경우에도 **외부 단편화** 가 존재한다.

---

## 1. 가정

malloc() 과 free () 에서 제공하는 것과 같은 기본 인터페이스를 가정한다.

- Allocation

  - Parameter: size
  - Return value: address (virtual)

   `void* malloc (size_t size)`

- Release

  - Parameter: address (virtual)
  - 사이즈를 알리지 않는다.

  `void free (void *ptr)`

이 라이브러리가 관리하는 공간을 역사적으로 **힙(heap)** 이라고 부르며, 힙의 **빈 공간** 을 관리하는 데는 일반적으로 링크드리스트가 사용된다.

이 자료구조는 영역 내의 모든 빈 공간 덩어리들에 대한 주소를 갖고 있다. (빈공간 덩어리의 시작주소, 길이를 저장.)

반드시 링크드리스트일 필요는 없다.

---

- 클라이언트에 할당된 메모리는 다른 위치로 재배치될 수 없다고 가정한다.

  즉, malloc 으로 메모리를 할당 받으면, free 로 해제될 때 까지 프로그램이 그 영역을 소유하게 되고, 해제될 떄 까지는 라이브러리가 다른 위치로 옮길 수 없다.

- **빈 공간의 압축** 방법은 사용할 수 없다고 가정한다.

---

## 2. 저수준 기법들

세부적인 기법에 대해 설명하기 전에, 일반론적으로 논의해 보자.

### 분할과 병합

- **분할 (splitting)**

  - 요청을 만족할 수 있는 **빈 공간 덩어리(free chunk of memory)** 를 찾는다.
  - 그 **빈 공간 덩어리(free chunk of memory)** 를 두개로 나눈다.

- **병합 (coalescing)**

  메모리 덩어리를 반환할 때 해제되는 덩어리의 주소와 바로 인접한 빈 덩어리의 주소를 검사한다.

  새로 해제된 빈 공간이 기존에 존재하는 빈 덩어리와 바로 인접해 있다면, 그들을 하나의 빈공간 덩어리로 병합한다.

---

### 할당된 공간의 크기 파악

`free (void *ptr)` 는 크기를 매개변수로 받지 않는다.

그렇다면 어떻게 어느정도의 메모리를 해제할 지 알아서 해제동작을 하는건가?

포인터 값을 받으면 해제되는 메모리의 크기를 파악해서 그 공간을 빈 공간 리스트에 추가시킬 수 있다고 하자.

메모리를 할당 할 때, 할당기가 추가 정보를 **헤더 (header)** 에 저장한다.

**헤더** 블럭은 메모리에 유지되고, 보통 해제된 덩어리 바로 직전에 위치한다.

- **헤더 (header)**

  - **size:** 배정된 메모리의 크기

  - **magic number:** 안정성 검사를 위한 숫자

    free를 호출하면, 헤더의 시작위치를 파악하기 위해 포인터 연산을 한다.

    이 때 얻어낸 포인터 값이 매직넘버가 나타내는 값과 일치하는지 비교하여 안정성 검사를 한다.

```c
typedef struct {
  int size;
  int magic;
} header_t;
```

```c
void free(void *ptr) {
  //header_t *hptr = (header_t *)ptr - 1; //책 코드
  header_t *hptr = (void *)ptr - sizeof(header_t); //강의자료 코드
}
```

빈 영역의 크기는 `헤더 크기 + 사용자에게 할당된 영역의 크기` 이다.

만약 사용자가 N byte 크기의 메모리 청크를 요청하면, 라이브러리는 N 의 빈 청크를 찾는게 아니라, `N + 헤더의 크기` 의 청크를 탐색한다.

---

### 빈 공간 리스트 내장 (embedding a free list)

빈 공간 리스트를 어떻게 빈 공간에 구현할 수 있는가?

만약 4KB 의 하나의 빈공간 덩어리 (힙)만 있다고 해보자.

```c
// mmap() 이 빈 공간의 청크에 대한 포인터를 반환
node_t *head = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE, -1, 0);
head->size = 4096 - sizeof(node_t);
head->next = NULL;
```

총 4096 (4KB)의 한덩어리의 빈공간 중에서,

head->size 로 4byte,

head->next 로 4byte 가 할당되어서

빈 공간 덩어리는 `4096 - sizeof(node_t)` = 4088 이다.

---

만약 이 상태에서 추가적인 메모리 요청 (malloc) 이 들어오면, 다음과 같은 과정을 거칠것이다.

- **split:** 큰 빈 메모리 청크를 두개로 나눈다.

  하나는 요청 받은 메모리이고, 하나는 남은 빈 메모리 청크.

- **shrink:** 리스트에서 빈 메모리 청크의 사이즈를 줄인다.

예를 들어, 다음과 같이 100byte 의 요청이 들어온다면

`ptr = malloc(100)`

하나의 빈 메모리 청크 (4088)을 3980으로 줄여야 할 것이다.

`(4096-8) - (100-8) = 3980`

이렇게 분할 된 메모리 헤더는 다음과 같을 것이다.

- 할당된 메모리의 헤더
  - size: 100
  - magic: 1234567 (그냥 임의의 숫자임)
- 빈 메모리 청크
  - size: 3980
  - next: 0

ptr 값은 할당된 메모리의 헤더 바로 다음을 가리키고 있을 것이다. (분리된 108byte 중 헤더 8byte를 빼고 할당받은 100 byte 의 시작부분)

---

만약 free 요청이 들어오면

할당되었던 메모리를 다시 free list 에 추가한다.

- 리스트 헤더는 새로 반환 된 덩어리를 가리킨다.(head 포인터는 항상 리스트의 맨앞 노드를 가리킨다.)
- 그 덩어리의 헤더의 next는 이전에 헤더가 가리키던 헤더의 주소를 가리킨다. 

이렇게 할당과 해제가 되다 보면, **외부 파편화 (external fragmentation)** 가 생겨 **병합 (coalescing)** 이 필요 할 때 가 있다.

- 병합

  리스트를 순회하면서 인접한 청크를 병합

---

### 힙의 확장 (growing the heap)

힙 공간이 부족할때는 어떻게 할 것인가?

대부분의 할당기(allocator)는 작은 크기의 힙으로 시작해서 힙이 모두 소진되면, 운영체제로부터 더 많은 메모리를 요청한다.

할당기는 힙의 확장을 위해, 특정 시스템 콜 (sbrk(), brk()) 를 호출한다.

그리고 새롭게 할당받은 영역에서 새로운 청크를 할당한다.

운영체제는 sbrk 요청을 받으면, 빈 물리 페이지를 찾아서 프로세스의 주소 공간에 매핑하고 새로운 힙의 마지막 주소를 반환한다.

---

## 3. 기본 전략

빈 공간 할당을 위한 기본전략에 대해 살펴보자.

- **최적 적합 (Best Fit)**
  1. 요청된 크기와 같거나 더 큰 빈 메모리 청크를 찾는다.
  2. 그 후보들 중에서 가장 작은 크기의 청크를 반환한다.
- **최악 적합 (Worst Fit)**
  1. 가장 큰 빈 청크를 찾는다
  2. 그 청크에서 요청된 크기 만큼만 잘라서 반환한다.

- **최초 적합 (First Fit)**

  1. 요청보다 큰 첫번째 청크를 찾는다. (젤 먼저 찾은 조건에 맞는거)
  2. 그 청크에서 요청된 크기 만큼만 잘라서 반환한다.

  - 장점: 속도가 빠르다.
  - 단점: 리스트의 시작에 크기가 작은 객체가 많이 생길 수 있다.

- **다음 적합 (Next Fit)**

  1. 마지막으로 찾았던 원소를 가리키는 추가의 포인터를 유지한다.
  2. 거기서부터 찾기 시작해서 조건에 맞는 걸 발견하면 그걸 바로 쓴다.

  - 다른 방법들과는 다르게 항상 리스트의 첫번째부터 탐색하는게 아니기 때문에, 리스트의 앞부분에 빈공간이 집중되는 것을 방지 할 수 있다.

  - 전체 탐색을 하지 않기 때문에 최초 적합의 성능과 비슷하다.

    (최적, 최악 적합을 하려면 전체를 다 순회 해 보고 판단해야 한다.)

---

- 15 크기의 할당을 요청한다고 하자.

  head->10->30->20->NULL

- **Best-Fit 결과**

  head->10->30->5->NULL

- **Worst-fit 결과**

  head->10->15->20->NULL

---

## 4. 다른 접근법

### 4.1. 개별 리스트 (segregated list)

특정 응용 프로그램이 한두 개 자주 요청하는 크기가 있다면, 그 크기의 객체를 관리하기 위한 별도의 리스트를 유지하는 것이다.

(맞춤형 메모리 크기 몇개를 준비 해 놓는것, 기성품 옷이 많이 입는 사이즈인 S, M, L 사이즈로 나눠서 있는 것 처럼)

- **장점:**

  - 단편화 가능성을 상당히 줄일 수 있다.

  - 정해진 크기의 청크들만 있기때문에 (완전 가변아님) 할당과 해제 요청을 신속히 처리 가능.

- **단점:**

  - 일반 메모리풀과 지정크기 메모리풀 두개를 나눠서 써야 하는데, 그 둘의 메모리 할당 비율을 어떻게 해야 하는가?

    slab allocator 가 이 문제를 해결한다.

- **slab allocator**

  커널이 부팅될 때 **커널 객체** 를 위한 여러 **객체 캐시(object cache)** 를 할당한다. (자주 쓰는 자료구조들을 위한 slab cache 를 미리 할당해 놓음.)

  **커널 객체** 란?: 자주 요청되는 자료 구조들.

  **객체 캐시 (object cache)** 는 정해진 크기의 객체들로 구성된 빈 공간 리스트이다.

  주어진 캐시 메모리가 부족해지면, 상위 메모리 할당기에게 추가 **슬랩(slab)** 을 요청한다.

---

### 4.2 버디 할당 (buddy allocation)

- **Binary Buddy Allocation (이진 버디 할당기)** (매우중요)

  요청된 메모리를 할당할 수 있는 한계까지 계속 반으로 쪼개서 가장 작은 사이즈를 할당한다.

  - 예)

    2^N 의 메모리를 할당할 건데, 64KB 가 최대라고 한다면,

    7KB 할당 요청이 들어오면,

    64

    32, 32

    16, 16, 32

    8, 8,16, 32

    이렇게 나눠서 8KB를 사용자에게 반환한다.

- **단점: Internal fragmentation 발생**

  예) 만약 33KB 요청? -> 32KB 보다 단 1KB 큰 상황...

  64KB - 33KB = 31KB 만큼 낭비.

- **장점: coalescing 을 간단하게 한다**

  같은 크기의 두개의 블럭을 합치면 다음 단계의 블럭 하나가 된다.

---

