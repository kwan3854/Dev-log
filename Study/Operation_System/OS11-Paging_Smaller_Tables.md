

# Paging: Smaller Tables

**핵심 질문: 페이지 테이블을 어떻게 더 작게 만들까**

## 1. 간단한 해법: 더 큰 페이지

간단하게 줄일 수 있는 방법이 있다. 페이지 크기를 증가시키면 된다.

### 가정

> 32비트 주소 공간에서 16KB 페이지를 가정해 보자.
>
> 각 PTE의 크기는 4byte로 동일.

### 결과

- VPN: 18bit
- offset: 14bit
- 페이지 테이블에 있는 항목의 개수: 2^18개
- 페이지 테이블의 총 크기: 1MB

- 기존 페이지 테이블 대비 크기 1/4로 감소 (페이지 크기를 4배 증가시켰기 때문)

---

### 더 큰 페이지의 문제점

페이지 내부의 낭비되는 공간이 증가한다.

이를 **내부 단편화 (internal fragmentation)** 라고 한다.

이 문제 때문에 실제 컴퓨터들은 보통 4KB (x86) 또는 8KB (SPARCv9) 크기의 페이지를 사용한다.

---

## 2. 하이브리드 접근 방법: 페이징과 세그멘트

**페이징과 세크멘테이션을 결합한 방법**

### 기존의 문제

힙과 스택에서 실제로 전체 공간 중 작은 부분만 사용되는 경우를 생각해보자.

페이지 테이블 대부분이 비어있게 된다.

### 해결방법 (페이징과 세그멘트의 결합)

프로세스의 전체 주소 공간을 위해 하나의 페이지 테이블을 두는 대신

논리 세그멘트마다 따로 페이지 테이블을 두자.

코드, 힙, 스택 영역 각각에 페이지 테이블을 하나씩 부여한다.

각각의 세그멘트마다 있는 베이스, 바운드 레지스터에서 베이스 레지스터는 이제부터 세그멘트 시작주소를 갖는게 아니라 해당 세그멘트의 페이지 테이블 시작주소를 갖는다.

---

### 가정

4KB 페이지를 갖는 32비트 가상주소.

가상주소는 다음과 같다

| 31, 30 (2bit) | 29~12 (18bit) | 11~0 (12bit) |
| ------------- | ------------- | ------------ |
| Seg           | VPN           | Offset       |

| Seg value | Content        |
| --------- | -------------- |
| 00        | unused segment |
| 01        | code           |
| 10        | heap           |
| 11        | stack          |

### 과정

1. 하드웨어는 세그멘트 비트(SN)을 사용하여 어떤 베이스와 바운드 쌍을 사용할지 결정한다.
2. 하드웨어는 그 레지스터에 들어 있는 물리 주소를 VPN과 다음과 같은 형식으로 조작하여 PTE의 주소를 얻는다

```pseudocode
SN	= (VirtualAddress & SEG_MASK) >> SN_SHIFT
VPN	= (VirtualAddress & VPN_MASK) >> VPN_SHIFT
AddressOfPTE = Base[SN] + (VPN * sizeof(PTE))
```

### 결과

- 장점

  - 선형 페이지 테이블에 비해 메모리 사용을 개선시킬 수 있다.

    스택과 힙 사이의 할당되지 않는 페이지들은 페이지 테이블 상에서 공간을 차지하지 않는다.

- 단점

  - 세그멘테이션을 사용하기 때문에 빈공간이 많은 힙의 경우 페이지 테이블의 낭비가 있다.

  - 외부 파편화를 유발한다.

    하이브리드 방식은 페이지 테이블 크기에 제한이 없으며 다양한 크기를 갖는다.

    페이지 테이블의 크기는 페이지 테이블 항목 크기의 정수배가 되긴 한다.

    그러나 이 때문에 메모리상에서 페이지 테이블용 공간을 확보하는게 더 복잡하다.

  - 내부 파편화도 발생

    heap malloc 했다가 free 하면 발생

---

## 3. 멀티 레벨 페이지 테이블

세그멘테이션을 사용하지 않고, 어떻게 하면 사용하지 않는 주소 공간을 페이지 테이블에서 제거할 수 있을까?

**멀티 레벨 페이지 테이블** 은 선형 페이지 테이블을 트리 구조로 표현한다.

매우 효율적이기 때문에 많은 현대 시스템에서 사용되고 있다(x86 등)

### 기본개념

1. 페이지 테이블을 페이지 크기의 단위로 나눈다. (예를들어 10페이지 단위, 100페이지 단위 등등)

2. 페이지 테이블의 페이지가 유효하지 않은 항목만 있으면, 해당 페이지를 할당하지 않는다.

3. **페이지 디렉터리 (page directory)** 라는 자료 구조를 사용해서 페이지 테이블 각 페이지의 할당 여부와 위치를 파악한다.

   페이지 디렉터리는 페이지 테이블을 구성하는 각 페이지의 존재 여부와 위치 정보를 가지고 있다.

>호빗이라는 엄청 두꺼운 책을 읽는다고 생각해보자.
>
>몇천 페이지짜리 책을 통째로 도서관에서 빌려와 봤자 엄청 무겁고 번거러울 뿐이다.
>
>엄청 두꺼운 책을 10권으로 쪼갠다.
>
>나는 쪼갠 책의 목차(page directory)를 가지고 읽을 부분만 골라서 도서관에서 빌려온다.

### 예시

---

**선형 페이지 테이블**

- PTBR(Page Table Base Register): 201

| valid | prot | PFN(Physical Frame Number) | PFN(Page Frame Number) |
| :---: | :--: | :------------------------: | :--------------------: |
|   1   |  rx  |             12             |       **PFN201**       |
|   1   |  rx  |             13             |       **PFN201**       |
|   0   |  -   |             -              |       **PFN201**       |
|   1   |  rw  |            100             |       **PFN201**       |
|   0   |  -   |             -              |         PFN202         |
|   0   |  -   |             -              |         PFN202         |
|   0   |  -   |             -              |         PFN202         |
|   0   |  -   |             -              |         PFN202         |
|   0   |  -   |             -              |       **PFN203**       |
|   0   |  -   |             -              |       **PFN203**       |
|   1   |  rw  |             86             |       **PFN203**       |
|   1   |  rw  |             15             |       **PFN203**       |

---

**Multi-level Page Table**

- PTBR(Page Table Base Register): 200

The Page Directory

|  PFN   | valid | PFN  |
| :----: | :---: | :--: |
| PFN200 |   1   | 201  |
| PFN200 |   0   |  -   |
| PFN200 |   0   |  -   |
| PFN200 |   1   | 203  |

| valid | prot | PFN  |  PFN   |
| :---: | :--: | :--: | :----: |
|   1   |  rx  |  12  | PFN201 |
|   1   |  rx  |  13  | PFN201 |
|   0   |  -   |  -   | PFN201 |
|   1   |  rw  | 100  | PFN201 |

[PT의 페이지1: 할당 안됨]

[PT의 페이지2: 할당 안됨]

| valid | prot | PFN  |  PFN   |
| :---: | :--: | :--: | :----: |
|   0   |  -   |  -   | PFN204 |
|   0   |  -   |  -   | PFN204 |
|   1   |  rw  |  86  | PFN204 |
|   1   |  rw  |  15  | PFN204 |

---

- 페이지 디렉터리는 **PDE (Page Directory Entries)** 로 구성된다.

- 각 **PDE** 는 **valid 비트** 와 **PFN (Page Frame Number)** 를 갖고 있다.

  valid 비트가 1이라는 것(유효하다는 것)은 그 항목이 PFN을 통해서 가리키고 있는 페이지들 중 최소한 하나가 유효하다는 것을 의미.

  만약 PDE의 valid bit 가 0이라면, PDE에 실제 페이지가 할당되어 있지 않다는 것.

---

### 장점

- 보다 작은 크기의 페이지 테이블로 주소 공간을 표현할 수 있다.

  -> 사용된 주소 공간의 크기에 비례하여 페이지 테이블 공간이 할당되기 때문.

- 메모리 관리가 매우 용이하다.

  -> 페이지 테이블을 페이지 크기로 분할했기 때문

### 단점

- TLB 미스 시, 주소 변환을 위해 두 번의 메모리 로드가 발생한다.

  -> 선형 테이블 방식에서는 한 번의 메모리 접근만 했으면 됐음.

- 복잡도 문제 발생

  -> 페이지 테이블 검색이 단순 선형 페이지 테이블의 경우보다 더 복잡해진다.

### 정리

멀티 레벨 테이블은 시간과 공간을 상호 절충한 예이다. **(time-space-trade-offs)**

페이지 테이블 크기를 줄이는 데 성공하였으나, 대신 메모리 접근 시간이 증가했다.

(TLB 히트시 성능은 같지만, TLB 미스 시 두 배의 시간이 소요된다.)

---

### 자세한 예시

| Flag             | Detail    |
| ---------------- | --------- |
| Address space    | 16 KB     |
| Page size        | 64 Byte   |
| Virtual address  | 14 bit    |
| VPN              | 8 bit     |
| Offset           | 6 bit     |
| Page table entry | 2^8 (256) |

주소 공간이 16KB(2^4 * 2^10 Byte) 이고, Page size가 64Byte(2^6Byte) 이니까

- VPN은 2^(14-6) = 2^8, 8bit 가 필요하다.

- Offset은 page size가 2^6 이니까 6bit가 필요. 

---

### Page Directory Index 적용

- Page Directory Index: 페이지 디렉터리에서의 인덱스
- Page Table Index: 페이지 디렉터리가 가리키는 페이지 테이블에서의 인덱스

**가정**

- 각각의 PTE가 4 byte 크기이다.
- Page table은 1KB (256 * 4 bytes) 이다.
- 각각의 페이지는 16개의 PTE를 가질 수 있다. -> VPN에 4bit의 Page Table Index 를 할당해야 한다.

| 13      | 12      | 11      | 10      | 9    | 8    | 7    | 6    | 5          | 4          | 3          | 2          | 1          | 0          |
| ------- | ------- | ------- | ------- | ---- | ---- | ---- | ---- | ---------- | ---------- | ---------- | ---------- | ---------- | ---------- |
| **PDI** | **PDI** | **PDI** | **PDI** | PTI  | PTI  | PTI  | PTI  | **Offset** | **Offset** | **Offset** | **Offset** | **Offset** | **Offset** |

뒤에서부터 오프셋, PTI, PDI 순으로 구하면 편하다.

---

### More than Two Level: Page Directory

어떤 경우에는 2단계 보다 많은 단계로 나눌 수 있다.

| 30~24      | 23~17      | 16~10            | 9~0    |
| ---------- | ---------- | ---------------- | ------ |
| PD Index 0 | PD Index 1 | Page Table Index | offset |
| VPN        | VPN        | VPN              | Offset |

---

## 4. 역 페이지 테이블 (Inverted Page Table)

공간 절약 방법으로 역 페이지 테이블(inverted page table)이 있다.

이 방법은 프로세스당 하나씩 페이지 테이블을 두는 대신, 시스템전체에 단 하나의 페이지 테이블만 둔다.

페이지 테이블은 물리 페이지를 가상 주소 상의 페이지로 변환한다.

역페이지 테이블의 각 엔트리는 해당 물리 페이지를 사용 중인 프로세스 번호, 해당 가상 페이지 번호를 갖고 있다.

그런데 프로그램은 가상 페이지 넘버로 돌아가는데, 페이지 테이블에는 물리 페이지 번호를 기반으로 매핑되어있어서 매번 테이블을 linear 하게 순회하면서 해당 가상 페이지 넘버를 찾아야 한다. O(n)

**메모리를 절약하기 위해 속도를 포기한 경우이다**

---

