# Virtual Memory

**핵심 질문: 메모리를 어떻게 가상화하는가?**

> 운영체제는 물리 메모리를 공유하는 다수의 프로세스에게 어떻게 프로세스 전용의 커다란 주소 공간이라는 개념을 제공할 수 있는가?

### 초기 시스템

초기 컴퓨터는 메모리 관점에서 많은 개념을 사용자에게 제공하지 않았다.

특별한 가상화는 존재하지 않았고 사용자도 운영체제에 그리 많은 것을 기대하지 않았다.

---

### 멀티프로그래밍과 시분할

시간이 흐른후, 컴퓨터가 고가 장비였기 때문에 사람들은 컴퓨터를 더 효과적으로 쓰고 싶어 했다.

**멀티프로그래밍 (multi-programming)** 시대가 도래했다.

> 여러 프로세스를 준비 상태에 놓고, 운영체제는 그들을 전환시켜가며 실행했다.

곧 사람들은 더 효율적인 것을 원하기 시작했고, **시분할 (time-sharing)** 의 시대가 시작되었다.

> 많은 사람들이 일괄처리방식 컴퓨팅의 한계를 인식하였으며, **대화식 이용 (interactivity)** 개념이 중요해졌다.

**시분할** 을 사용하면서 다음과 같은 문제가 생겨났다.

- 너무 느리게 동작한다는 점.

  내용 전체를 디스크에 저장하는 것은 너무 느리다. 프로세스 전환시 프로세스를 메모리에 그대로 두면서, 시분할 시스템을 구현해야 한다.

- 여러 프로그램이 메모리에 동시에 존재하기 위해 **보호 (protection)** 문제가 발생.

  한 프로세스가 다른 프로세스의 메모리를 읽거나 악용될 가능성이 있다.

---

### 주소 공간

운영체제를 만들때는 그런 악용되는 경우 또한 생각해야한다.

그 위험에 대비해서 운영체제는 **사용하기 쉬운 (easy to use)** 메모리 개념을 만들어야 한다.

이 개념이 바로 **주소공간 (address space)** 이다.

**주소 공간** 은 프로그램의 모든 메모리 상태를 가지고 있다.

- **코드 (code, 명령어):**  반드시 메모리에 존재해야 한다.
- **스택 (stack):**  함수 호출 체인 상의 현재 위치, 지역 변수, 함수 인자와 반환 값 등을 저장한다.
- **힙 (heap):** 동적으로 할당되는 메모리를 위해 사용된다. `malloc()`, `new` 등으로 메모리를 동적으로 할당받는다.

운영체제는 실행 중인 프로그램에게 **개념 (abstraction)** 을 제공한다.

운영체제가 하는 이 작업을 **메모리 가상화 (virtualizing memory)** 라고 말한다.

프로세스는 **가상 주소 (virtual address)** 를 통해 메모리 연산을 하고, 운영체제는 이 **가상 주소** 가 실제 **physical memory** 와 매핑이 되도록 보장해야 한다. 

다시말해, 프로세스가 실제 물리적 메모리 공간크기 제약 없이 시스템상 최대의 메모리를 제약없이 다 가지고 있다고 생각하고 동작해도, 운영체제는 이 동작을 보장해야 한다.

---

### 목표

운영체제가 가상화를 멋지게 해내기 위해서는 몇가지 목표가 필요하다.

- **투명성 transparency)**

  운영체제는 실행 중인 프로그램이 **가상 메모리** 의 존재를 인지하지 못하도록 구현되어야 한다. 즉 **메모리 가상화** 자체를 인지하게 해서는 안된다.

  오히려 프로그램은 자신이 자기 전용의 물리 메모리가 있는 것처럼 행동해야 한다.

- **효율성 (efficiency)**

  운영체제는 가상화가 시간과 공간 측면에서 효율적으로 동작하게 해야한다.

  너무 느려서도 안되고, 메모리 공간을 너무 많이 차지해서도 안된다.

  시간 문제를 해결하기 위해 **TLB** 라는 하드웨어 기능을 포함한 하드웨어의 지원을 받아야 한다. 자세한 것은 나중에 배운다.

- **보호 (protection)**

  운영체제는 프로세스를 다른 프로세스로부터 보호해야 하고 운영체제 자신도 프로세스로부터 보호해야 한다.

  프로세스들을 서로 **격리 (isolate)** 시켜야 한다.

---

### 여담

**당신이 보는 모든 주소는 가상 주소이다**

나는 개인적으로 C 프로그래밍을 할때 내가 만든 포인터 연산 오류가 컴퓨터를 완전히 복구 불능의 상태로 몰아넣지는 않을지 걱정한 적이 있다.

하지만 그런 걱정을 할 필요가 없었다.

포인터 연산 등으로 보여지는 모든 주소는 사실 **가상 주소** 이다.

실제 주소는 운영체제와 하드웨어만이 알고 있다.

---

## 주소 변환의 원리

**핵심 질문: 어떻게 효율적이고 유연하게 메모리를 가상화하는가?**

CPU 가상화 부분에서 **제한적 직접 실행 (LDE)** 라는 기법을 다루었었다.

메모리 가상화도 이와 비슷한 전략을 취한다.

우리가 다룰 방법은 **하드웨어 기반 주소 변환 (hardware-based address translation)** 또는 **주소 변환 (address translation)** 이다.

> 하드웨어는 명령어 반입, 탑재, 저장 등의 **가상 주소** 를 정보가 실제 존재하는 **물리 주소** 로 변환한다.
>
> 정확한 변환을 위해서는 하드웨어에 더불어 운영체제가 관여해야한다.

**핵심 목표** 는 프로그램이 자신의 전용 메모리를 소유하고 있다는 **환상** 을 만드는 것이다.

## 1. 가정

처음에는 정말 간단히 생각해 본다. 다음과 같이 가정해보자.

- **사용자 주소 공간** 은 **물리 메모리** 에 **연속적** 으로 배치된다.
- **주소 공간**은 **물리 메모리** 크기보다 작다.
- 각 **주소 공간** 의 크기는 같다.

물론 비현실적인 가정이다. 앞으로 천천히 이 가정들을 완화시켜 갈 것이다.

---

## 2. 사례

다음 C 코드를 분석해보자.

```c
void func()
{
  int x = 3000;
  x = x + 3; // 이 부분을 주목
}
```

1. **Load:** 값을 메모리로부터 로드한다.
2. **Increament:** 값을 3 증가한다.
3. **Store:** 값을 메모리에 다시 저장한다.

이를 어셈블리 코드로 보면 다음과 같다.

```assembly
128: movl 0x0(\%ebx), \%eax		; 0+ebx를 eax에 저장한다.
132: addl \$0x03, \%eax		; eax레지스터에 3을 더한다.
135: movl \%eax, 0x0(\%ebx)		; eax를 메모리에 다시 저장한다.
```

1. x의 주소는 레지스터 **ebx**에 저장되어 있다고 가정한다.
2. **Load:** 이 주소에 저장되어 있는 값을 `movl` 명령어 (longword를 이동하는 명령어) 로 범용 레지스터 **eax**에 넣는다.
3. **Add:** **eax**에 3을 더한다.
4. **Store:** **eax** 의 값을 같은 위치의 메모리에 저장한다.

프로그램 관점에서 **주소 공간** 은 주소 0부터 시작해서 16KB 까지 이다.

운영체제는 실제 프로세스를 물리 메모리 0이 아닌곳에 위치하고싶다.

어떻게 하면 프로세스 모르게 실제 다른 위치에 **재배치** 하느냐가 문제이다.

어떻게 하면 프로세스가 주소 0번지부터 시작하는 가상 주소 공간의 **환상** 을 가지게 할 것인가?

---

## 3. 동적 (하드웨어 기반) 재배치 (dynamic relocation)

**베이스와 바운드 (base and bound)** 라는 개념, a.k.a **동적 재배치 (dynamic relocation)** 이라는 개념을 사용한다.

각 CPU 마다 2개의 레지스터

- **베이스 (base)** 레지스터
- **바운드 (bound)** 레지스터

를 사용한다.

1. 각 프로그램은 주소 0에 탑재되는 것처럼 작성되고 컴파일된다.

2. 운영체제가 프로그램이 탑재될 물리 메모리 위치를 결정한다.

3. 베이스 레지스터를 그 주소로 지정한다.

4. 프로세스가 실행되면 프로세스에 의해 생성되는 모든 주소가 **프로세서(MMU)** 에 의해 **변환** 된다.

   `physical address` = `virtual address` + `base`

그렇다면 **바운드 레지스터** 는 어디에 쓰이는가?

**바운드 레지스터** 는 보호를 지원하기 위해 존재한다.

모든 주소가 합법적이고 범위내에 있다는 것을 확인한다.

**베이스와 바운드 레지스터** 는 CPU 칩 상에 존재하는 **하드웨어 구조** 이다!

주소 변환에 도움을 주는 프로세서의 일부를 **메모리 관리 장치 (memory management unit, MMU)** 라고 부른다.

---

### 정리

- **MMU** 라는 하드웨어 장치가 메모리 주소 변환을 한다.
- **하드웨어** 에 의해 보호된다. (가상주소가 valid 하지 않으면 MMU가 execption을 던진다.)
- **OS** 는 현재 프로세스의 valid한 주소 공간에 대한 정보를 **MMU** 에게 준다. (어떤 주소가 valid 한가?)
- **base** 는 **physical 메모리** 의 시작주소, **bound** 는 **address apace** 의 사이즈를 의미한다. (시작 주소와 사이즈를 알면 메모리의 어디서 어디까지 위치할지 특정된다.)
- `physical adress`= `virtual address` + `base`
- 0 <= `virtual address`< `bound` (당연히 bound가 virtual address의 전체 사이즈이기 때문에 전체 사이즈보다 커질 수는 없다.)

**bound** 를 **address space** 의 사이즈가 아니라 **physical 주소** 의 끝 주소를 주는 경우도 있다.

---

### 여담: 소프트웨어-기반 재배치 (static relocation)

이 기술은 **정적 재배치** 라고 부른다. **로더 (loader)** 라는 소프트웨어가 실행할 실행 파일의 모든 주소를 원하는 물리 메모리 오프셋으로 변경한다.

단점이 많은 방식이다. 초창기 하드웨어 지원이 생기기 전 사용되던 방식으로 요즘은 안쓴다.

- 장점

  하드웨어 지원이 필요없다.

- 단점

  - 보호 기능이 없다.
  - 한번 배치하면 재배치가 어렵다.

---

## 4. 운영체제 이슈

**base-and-bound** 를 구현하기 위해서는 **OS** 가 반드시 개입해야 한다.

다음 세가지의 운영체제가 반드시 개입해야 하는 상황이 발생한다.

- 프로세스가 생성될 때

  운영체제는 **주소 공간** 이 저장될 **physical memory** 를 찾아야 한다.

  새로운 프로세스가 생성되면 운영체제는 **free list** 라고 불리는 자료 구조를 검색해야 한다.

  그리고 선택된 공간을 사용 중으로 표시한다.

- 프로세스를 종료할 때

  종료된 프로세스가 사용하던 메모리를 회수하여 다른 프로세스나 운영체제가 사용할 수 있게 해야한다.

  운영체제는 종료한 프로세스의 메모리를 다시 **free list** 에 넣고 연관된 자료구조를 모두 정리한다.

- **문맥 교환 (context switch)** 가 일어날 때

  운영체제는 프로세스 전환 시 **베이스와 바운드** 쌍을 저장하고 복원해야 한다.

  프로세스를 종료시킬때는 메모리에 존재하는 프로세스 별 자료 구조 안에 **베이스와 바운드 레지스터** 값을 저장한다.

  이 자료 구조를 **프로세스 구조체 (process structure)** 또는 **프로세스 제어 블럭 (process contrl block, PCB)** 라고 부른다.

  프로세스를 실행할때는 이 프로세스에 맞는 값으로 CPU의 **베이스와 바운드** 값을 설정해야 한다.

운영체제는 **예외 핸들러 (exeption handler)** 혹은 호출될 함수를 제공해야 한다.

운영체제는 부팅할 때 특권 명령어를 사용하여 이 핸들러를 설치한다.

운영체제는 예외가 발생할 때 조치를 취할 준비가 되어 있어야 한다.

---

## 5. 요약

- 주소 변환에는 하드웨어 지원이 필수적이다.
- 베이스와 바운드 (동적 재배치) 를 알아봤다. 간단한 하드웨어를 이용하기 때문에 매우 효율적이다. 보호기능도 지원한다.
- **동적 재배치** 는 비효율적이다. **내부 단편화 (internel fragmentation)** 이 발생한다.

**내부 단편화** 는 어떻게 해결할까?

**베이스 바운드** 기법을 일반화 하여 해결해 본다.

이런 일반화된 베이스 바운드 기법을 **세그멘테이션 (segmentation)** 이라 부른다. 다음에 자세히 배운다.



