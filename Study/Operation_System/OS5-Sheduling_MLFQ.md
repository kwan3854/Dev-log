# Scheduling: The Multi_Level Feedback Queue

**핵심 질문: 정보 없이 스케줄 하는 방법은 무엇인가?**

> 작업의 실행 시간에 대한 선행 정보 없이 대화형 작업의 응답 시간을 최소화하고 동시에 반환 시간을 최소화하는 스케줄러를 어떻게 설계할 수 있는가?

---

## 1. MLFQ: 기본 규칙

**MLFQ** 란 무엇인가?

> **MLFQ** 는 여러 개의 **Queue** 로 구성되며, 각각 다른 **우선순위 (priority level)** 가 배정된다.
>
> 실행 준비가 된 프로세스는 이 중 하나의 큐에 존재한다.
>
> 높은 **우선순위** 를 가진 작업이, 즉 높은 **우선순위 큐** 에 존재하는 작업이 선택된다.

**MLFQ** 의 **기본 규칙** 은 다음과 같다.

- **규칙 1:** Priority(A) > Priority(B) 이면, A가 실행된다. (B는 실행되지 않는다.)
- **규칙 2:** Priority(A) = Priority(B) 이면, A와 B는 **RR** 방식으로 실행된다.

핵심은 **우선순위를 정하는 방식** 이다.

- 각각의 작업의 특성에 따라 동적으로 우선순위를 부여한다.
- 어떤 작업이 반복적으로 CPU를 양보한다면, 해당 작업의 우선순위를 높게 유지한다.
- 어떤 작업이 긴 시간 동안 CPU를 집중적으로 사용하면 해당 작업의 우선순위를 낮춘다.

---

## 2. 시도 1: 우선순위의 변경

**MLFQ** 가 작업의 우선순위를 어떻게 바꿀 것인지 결정해야 한다.

이는 작업이 존재할 **queue** 를 결정하는 것과 같은 의미이다.

**우선순위 조정 알고리즘** 을 위해 다음과 같은 규칙을 추가해보자.

- **규칙 3:** 작업이 시스템에 진입하면, 가장 높은 우선순위, 즉 맨 위의 큐에 놓여진다.
- **규칙 4a:** 주어진 타임 슬라이스를 모두 사용하면 우선순위는 낮아진다. 즉, 한단계 아래 큐로 이동한다.
- **규칙 4b:** 타임 슬라이스를 소진하기 전에 CPU를 양도하면 같은 우선순위를 유지한다.

---

### 2.1 예 1: 한 개의 긴 실행 시간을 가진 작업

1. 작업은 최고 우선순위로 진입한다.
2. 타임 슬라이스가 하나 지나면 스케줄러는 우선순위를 한 단계 낮춘다.
3. 또 다시 타임 슬라이스가 지나면 우선순위를 한 단계 또 낮춘다.
4. 계속 반복되다가 결국 가장 낮은 타임 슬라이스에서 계속 머물게 된다.

---

### 2.2 예 2: 짧은 작업과 함께

**MLFQ** 가 어떻게 **SJF** 에 근접할 수 있는지 이해할 수 있어야 한다.

두 개의 작업이 존재한다.

- **A** 는 오래 실행되는 CPU 위주 작업이다. A는 먼저 도착해 실행되고 있었다.
- **B** 는 이제 도착했다.

이들은 다음과 같이 동작할 것이다.

1. **A** 는 제일 아래 우선순위의 **큐** 에서 계속 동작하고 있었다.
2. **B** 가 가장 높은 우선순위의 **큐** 로 들어와서 실행된다.
3. 타임 슬라이스가 하나 지날 때마다 **B** 의 우선순위가 떨어지면서 계속 실행된다.
4. **B** 가 결국 마지막 우선순위까지 떨어지면 다시 **A** 가 실행된다.

스케줄러는 작업이 짧은 작업인지 긴 작업인지 알 수 없다.

따라서 일단 짧은 작업이라 가정하고 높은 우선순위를 준다.

짧은 작업이 아니라면 점점 우선순위가 낮아질 것이고,

짧은 작업이라면 빨리 실행되고 종료될 것이다.

이러한 방식으로 **MLFQ** 는 **SJF** 에 근접할 수 있다.

---

### 2.3 예 3: 입출력 작업에 대해서는 어떻게?

**규칙 4b** 에 따라 프로세스가 타임 슬라이스를 소진하기 전에 프로세서를 양도하면 같은 우선순위를 유지하게 된다.

자주 입출력을 수행하면 타임 슬라이스가 종료되기 전에 CPU를 양도하게 될 것이다.

그런 경우 동일한 우선순위를 유지하게 된다.

다음 예를 보자

- **B** 는 대화형 작업으로서, 입출력을 수행하기 전에 1ms 동안만 수행된다. (타임슬라이스는 10ms 라고 하자.) 
- **A** 는 긴 배치형 작업으로서 **B** 와 **CPU** 를 사용하기 위해 경쟁한다.

**MLFQ** 방식은 **B** 를 계속해서 가장 높은 우선순위에 유지시킬 것이다. (계속해서 CPU를 양도하기 때문에.)

**B** 가 대화형 작업이라면 **MLFQ** 는 대화형 작업을 빨리 실행시킨다는 목표에 근접한 것이다.

---

### 2.4 현재 MLFQ의 문제점

이 방식은 심각한 결점을 가지고 있다.

1. **첫째:** **기아 상태 (starvation)** 가 발생할 수 있다.

   계속 해서 대화형 작업이 생기면, 긴 실행 시간 작업은 CPU를 할당 받지 못할것이다.

2. **둘쨰:** 의도적으로 스케줄러를 자신에게 유리하게 작동하도록 프로그래밍 할 수 있다.

   타임 슬라이스가 끝나기 전에 아무 파일을 대상으로 입출력 요청을 계속 하면 무한히 높은 큐를 유지하여, 만약 타임슬라이스가 끝나기 직전에 입출력 요청을 하는 것을 반복하면, CPU를 거의 독점 할 수 있다.

3. **셋째**: 시간의 흐름에 따라 프로그램의 특성이 변할 수 있다.

   만약 CPU 위주의 작업이 나중에 대화형 작업으로 바뀐다면 현재 방식으로는 다른 대화형 작업들보다 천대할 수 밖에 없다.

---

## 3. 시도 2: 우선순위의 상향 조정

간단한 방법으로는 모든 작업의 우선순위를 **상향 조정 (boost)** 하는 방법이 있다.

- **규칙 5:** 일정 기간 *S* 가 지나면, 시스템의 모든 작업을 최상위 큐로 이동시킨다.

새로운 규칙은 첫번째와 두번째 문제, 두 가지 문제를 모두 해결한다.

여기서는 *S* 값을 얼마로 할지 결정하는것이 중요하다.

**John Ousterhout** 는 이러한 종류의 값을 **부두 상수 (voo-doo constants)** 라고 불렀다.

정확한 값을 결정하기 위해서는 흑마술이 필요한 것처럼 보이기 때문이다.

*S* 는 이 **부두 상수** 에 속한다.

- 너무 크면 긴 실행 시간을 가진 작업이 굶을 수 있다.
- 너무 작으면 대화형 작업이 적절한 양의 CPU 시간을 사용할 수 없다.

---

## 4. 시도 3: 더 나은 시간 측정

남은 문제가 하나 있다. 우선순위를 높게 유지하게 악의적으로 조작된 프로그램에 어떻게 대응하는가?

해결책은 **MLFQ** 단계에서 **CPU의 총 사용 시간을 측정** 하는 것이다.

스케줄러는 현재 단계에서 프로세스가 소진한 CPU 사용 시간을 저장한다.

프로세스가 타임 슬라이스에 해당하는 시간을 모두 소진하면 다음 우선순위 큐로 강등된다. 한꺼번에 소비하든, 나눠서 소비하든 상관없다.

**규칙 4a** 와 **규칙 4b** 를 합쳐 하나의 규칙으로 재정의 한다.

- **규칙 4:** 주어진 단계에서 시간 할당량을 소진하면 (CPU의 양도와는 상관없이), 우선순위는 낮아진다 (아래 단계 큐로 이동).

---

## 5. MLFQ 조정과 다른 쟁점들

아직 몇가지 쟁점이 남아 있다.

필요한 변수들을 스케줄러가 어떻게 설정해야 되는지도 중요한 문제이다.

예를 들어,

- 몇 개의 큐가 존재해야 하는가?
- 큐당 타임 슬라이스의 크기는 얼마로 해야 하는가?
- 얼마나 자주 우선순위가 상향 조정 되어야 하는가?

정답이 있는 것은 아니다.

**Solaris** 의 **MLFQ** 구현, **FreeBSD** 의 구현 등을 참고하면 좋다.

---

## 6. MLFQ: 요약

**멀티 레벨 피드백 큐** 는 과거를 지침으로 현재의 우선순위를 지정한다.

- **규칙 1:** 우선순위(A) > 우선순위(B) 인 경우, A가 실행, B는 실행되지 않는다.
- **규칙 2:** 우선순위(A) = 우선순위(B) 인 경우, A와 B는 RR 방식으로 실행된다.
- **규칙 3:** 작업이 시스템에 들어가면 최상위 큐에 배치된다.
- **규칙 4:** 작업이 지정된 단계에서 배정받은 시간을 소진하면 (CPU 양도와 상관없이), 작업의 우선순위는 감소한다 (아래 단계 큐로 이동).
- **규칙 5:** 일정 주기 *S* 가 지난 후, 시스템의 모든 작업을 최상위 큐로 이동시킨다.

**BSD UNIX** 와 여기서 파생된 다양한 운영체제, **Solaris** , **Windows NT** 및 이후의 **Windows 운영체제** 를 포함한 많은 시스템이 기본 스케줄러로 MLFQ를 사용한다.

