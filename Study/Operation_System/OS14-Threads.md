# Threads

## 병행성: 개요

프로그램에서 한 순간에 하나의 명령어만을 실행하는 고전적인 관점에서 벗어나 멀티 쓰레드 프로그램은 하나 이상의 실행 지점을 가지고 있다.

멀티 쓰레드는 프로세스와 매우 유사하지만, 쓰레드들은 주소 공간을 공유하기 때문에 동일한 값에 접근할 수 있다는 점이 프로세스와 다르다.

쓰레드는 어디서 명령어들을 불러 들일지 추적하는 **프로그램 카운터(PC)** 와 연산을 위한 **레지스터** 들을 가지고 있다.

만약 두 쓰레드가 하나의 프로세서에서 실행 중이라면 실행하고자 하는 쓰레드는 반드시 **문맥 교환(context switch)** 을 통해서 실행중인 쓰레드와 교체되어야 한다.

*프로세스와 쓰레드의 비교*

- **프로세스**
  - 문맥 교환 시 프로세스의 상태를 **프로세스 제어 블럭(process control block, PCB)** 에 저장
  - 단일 쓰레드 프로세스에서는 스택이 하나만 존재
- **쓰레드**
  - 프로세스의 쓰레드들의 상태를 저장하기 위해 하나 또는 그 이상의 **쓰레드 제어 블럭(thread control block, TCB)** 이 필요
  - 프로세스의 경우와 달리 **쓰레드 간의 문맥 교환에서는 주소 공간을 그대로 사용**
  - 멀티 쓰레드 프로세스의 경우에는 주소 공간에 하나의 스택이 아니라 **쓰레드마다 스택이 할당**

## 1. 왜 쓰레드를 사용하는가?

쓰레드를 사용해야 하는 2가지 주요 이유가 있다.

1. **병렬 처리(parallelism)**

   멀티프로세서 시스템에서 프로그램을 실행하는 경우 각 프로세서가 작업의 일부분을 수행하게 함으로써 실행 속도를 상당히 높일 수 있다.

   표준 **단일 쓰레드(single-threaded)** 프로그램을 멀티프로세서상에서 같은 작업을 하는 프로그램으로 변환하는 작업을 **병렬화(parallelization)** 이라고 한다.

2. **느린 I/O 로 인해 프로그램 실행이 멈추지 않도록 하기 위해**

   쓰레드를 사용하면 진행이 막히는 것을 자연스럽게 피할 수 있다.

   쓰레딩은 하나의 프로그램 안에서 I/O 와 다른 작업이 **중첩(overlap)** 될 수 있게 한다.

   이는 여러 프로그램을 대상으로 프로세스를 **멀티프로그래밍(multiprogramming)** 하는 것과 비슷하다.

결과적으로 최신의 많은 서버 기반 응용프로그램 (웹 서버, 데이터베이스 관리 시스템 등)을 구현할 때 쓰레드를 사용한다.

## 2. 예제: 쓰레드 생성

한 쓰레드는 "A"라고 출력하고 다른 쓰레드는 "B"라고 출력하는 독립적인 두 개의 쓰레드를 생성하는 프로그램을 실행시킨다고 해 보자.

```c
#include <stdio.h>
#include <assert.h>
#include <pthread.h>
#include "common.h"
#include "common_threads.h"

void *mythread(void *arg) {
  printf("%s\n", (char *) arg);
  return NULL;
}

int
main(int argc, char *argv[]) {
  pthread_t p1, p2;
  int rc;
  printf("main: begin\n");
  Pthread_create(&p1, NULL, mythread, "A");
  Pthread_create(&p2, NULL, mythread, "B");
  // 종료 할 수 있도록 대기 중인 쓰레드 병합하기
  Pthread_join(p1, NULL);
  Pthread_join(p2, NULL);
  printf("main: end\n");
  return 0;
}
```

실행 중에는 세 개의 쓰레드,

1. 메인쓰레드
2. T1
3. T2

가 사용된다.

이 프로그램의 실행 순서를 살펴보자.

| Main               | 쓰레드 1 | 쓰레드 2 |
| ------------------ | -------- | -------- |
| 실행 시작          |          |          |
| "main: begin" 출력 |          |          |
| 쓰레드 1 생성      |          |          |
| 쓰레드 2 생성      |          |          |
| T1을 대기          |          |          |
|                    | 실행     |          |
|                    | "A" 출력 |          |
|                    | 리턴     |          |
| T2를 대기          |          |          |
|                    |          | 실행     |
|                    |          | "B" 출력 |
|                    |          | 리턴     |
| "main: end" 출력   |          |          |

다음처럼 쓰레드가 생성된 후 즉시 실행될 수도 있다.

| Main               | 쓰레드 1 | 쓰레드 2 |
| ------------------ | -------- | -------- |
| 실행 시작          |          |          |
| "main: begin" 출력 |          |          |
| 쓰레드 1 생성      |          |          |
|                    | 실행     |          |
|                    | "A" 출력 |          |
|                    | 리턴     |          |
| 쓰레드 2 생성      |          |          |
|                    |          | 실행     |
|                    |          | "B" 출력 |
|                    |          | 리턴     |
| T1을 대기          |          |          |
| 즉시 리턴: T1 완료 |          |          |
| T2를 대기          |          |          |
| 즉시 리턴: T2 완료 |          |          |
| "main: end" 출력   |          |          |

쓰레드 1이 쓰레드 2보다 먼저 생성된 경우라 하더라도 만약 스케줄러가 쓰레드 2를 먼저 실행하면 "B"가 "A" 보다 먼저 출력될 수도 있다.

| Main               | 쓰레드 1 | 쓰레드 2 |
| ------------------ | -------- | -------- |
| 실행 시작          |          |          |
| "main: begin" 출력 |          |          |
| 쓰레드 1 생성      |          |          |
| 쓰레드 2 생성      |          |          |
|                    |          | 실행     |
|                    |          | "B" 출력 |
|                    |          | 리턴     |
| T1을 대기          |          |          |
|                    | 실행     |          |
|                    | "A" 출력 |          |
|                    | 리턴     |          |
| T2를 대기          |          |          |
| 즉시 리턴: T2 완료 |          |          |
| "main: end" 출력   |          |          |



다음에 실행될 쓰레드는 **OS 스케줄러(scheduler)** 에 의해 결정되며, 특정 순간에 어떤 쓰레드가 실행될 지 알아내는 것은 어렵다.

컴퓨터는 병행성이 없어도 충분히 어려운데, 이 문제 때문에 더 어려워진다. 훨씬.

## 3. 훨씬 더 어려운 이유: 데이터의 공유

다음 코드를 보며 전역 공유 변수를 갱신하는 두 개의 쓰레드에 대한 간단한 예제를 살펴보자.

코드를 보기 전 짚고 넘어가야 할 것이 있다.

1. 이 예제에서는 쓰레드를 생성하는 루틴과 조인하는 루틴이 실패할 경우 간단하게 종료하도록 래퍼 함수를 만들었다.

   이런 간단한 예제의 경우 에러 발생 여부만 관심이 있어, 종료 외에 다른 처리는 하지 않는다.

2. 작업자 쓰레드를 위해 두 개의 독립된 함수를 구성하는 대신 하나의 단일 코드를 사용하였다.

3. 가장 중요한 것은 각 작업자가 무엇을 하려는지 알 수 있다는 것이다.

   각 작업자 쓰레드는 반복문 안에서 공유 변수인 counter 에 수를 천만 번 더한다.

   결과적으로 최종적으로 얻으려는 값은 20,000,000,000 이다.

```c
#include <stdio.h>
#include <pthread.h>
#include "common.h"
#include "common_threads.h"

static volatile int counter = 0;

// mythread()
// 반복문을 사용하여 단순히 1씩 더하기
// 10,000,000을 변수 counter에 더하는 방법이 아니다.
// 하지만, 문제가 무엇인지 명확하게 해 준다.
void *mythread(void *arg)
{
  printf("%s: begin\n", (char *) arg);
  int i;
  for (i = 0; i < 1e7; i++) {
    counter = counter + 1;
  }
  printf("%s: done\n", (char *) arg);
  return NULL;
}

// main()
// 두 개의 쓰레드를 실행하고 (pthread_create)
// eorlgksek (pthread_join)
int main(int argc, char *argv[])
{
  pthread_t p1, p2;
  printf("main: begin (counter = %d)\n", counter);
  Pthread_create(&p1, NULL, mythread, "A");
  Pthread_create(&p2, NULL, mythread, "B");
  
  // 쓰레드가 종료할 수 있도록 대기 중인 쓰레드를 병합한다
  Pthread_join(p1, NULL);
  Pthread_join(p2, NULL);
  printf("main: done with both (counter = %d)\n", counter);
  return 0;
}
```

```shell
prompt> gcc -o main main.c -Wall -pthread; ./main
main: begin (counter= 0)
A: begin
B: begin
A: done
B: done
main: done with both (counter = 20000000)
```

이 예제 코드를 실행하면 단일 프로세서라 하더라도 기대한 대로 결과가 출력되지는 않는다. 때로는 아래와 같은 결과가 나온다.

```shell
prompt> ./main
main: begin (counter = 0)
A: begin
B: begin
A: done
B: done
main: done with both (counter = 19345221)
```

```shell
prompt> ./main
main: begin (counter = 0)
A: begin
B: begin
A: done
B: done
main: done with both (counter = 19221041)
```

**왜 이런일이 일어나는 것일까?**

## 4. 문제의 핵심: 제어 없는 스케줄링

왜 이런 현상이 발생하는지 이해하려면 counter 갱신을 위해서 컴파일러가 생성한 코드의 실행 순서를 이해해야 한다. 카운터에 단순히 (1) 이라는 숫자를 더하려고 한다. x86에서 counter를 증가하는 코드의 순서는 다음과 같다.

```assembly
mov 0x8049a1c, %eax
add $0x1, %eax
mov %eax, 0x8049a1c
```

couter 변수의 주소는 0x8049a1c 라고 가정한다.

위 코드가 동작하는 과정은 다음과 같다.

1. mov 명령어가 명시한 메모리 주소의 값을 읽어들인 후 eax 레지스터에 넣는다.
2. 1(0x1) 을 eax 레지스터의 값에 더하는 연산을 한다
3. eax에 저장되어 있는 값을 메모리의 원래의 주소에 다시 저장한다.

---

1. **쓰레드 1이 counter를 증가시키는 코드 영역에 진입하여 counter의 값을 1 증가시키는 상황을 가정해 보자.**

1. counter 에 있는 값이 50이었다고 하면 50을 eax레지스터에 넣는다. 쓰레드 1에 있어서 eax=50이 된다.

2. 그 후, 레지스터의 값에 1을 더하여 eax=51이 된다.

3. 타이머 인터럽트가 발생하여 운영체제가 실행중인 쓰레드의 pc 값과 eax를 포함한 레지스터들의 현재 상태를 쓰레드의 TCB에 저장한다.

4. **쓰레드 2 가 선택되고 counter 값을 증가시키는 똑같은 코드 영역에 진입한다.**

5. 첫 번째 명령어를 실행하여 counter 값을 얻어 온 후 eax에 넣는다.

   > 쓰레드는 개별적으로 쓰레드 전용 레지스터를 가지고 있다. 사용 중이던 레지스터들을 저장하고 복구하는 문맥 교환 코드에 의해 이 레지스터들은 가상화된다.

6. counter 값은 아직 50을 나타내고 있어서 쓰레드 2의 eax 값은 50이다.

7. 쓰레드 2가 그 다음의 두 문장을 실행하면 eax 값을 1 증가시키고 (eax=51) eax 값을 counter(0x8049a1c)에 저장한다.

8. 전역 변수인 counter는 이제 51이라는 값을 가진다.

9. 다시 문맥 교환이 생겨 쓰레드 1이 실행된다.

10. 쓰레드 1은 마지막의 mov 명령어를 수행하려는 중이었다. 그리고 eax=51 이었다.

11. mov 명령어가 실행되면 메모리에 레지스터의 값을 저장하여 counter 값은 다시 51이 된다. 

원래는 52가 되도록 의도한 코드였지만 51이 되어버렸다.

| OS            | Thread 1            | Thread 2            | PC(명령 실행 후) | %eax(명령 실행 후) | counter(명령 실행 후) |
| ------------- | ------------------- | ------------------- | :--------------: | :----------------: | :-------------------: |
|               | 임계 영역 전        |                     |       100        |         0          |          50           |
|               | mov 0x8049a1c, %eax |                     |       105        |       **50**       |          50           |
|               | add $0x1, %eax      |                     |       108        |       **51**       |          50           |
| **interrupt** |                     |                     |                  |                    |                       |
| T1 상태 저장  |                     |                     |                  |                    |                       |
| T2 상태 복원  |                     |                     |       100        |         0          |          50           |
|               |                     | mov 0x8049a1c, %eax |       105        |       **50**       |          50           |
|               |                     | add $0x1, %eax      |       108        |       **51**       |          50           |
|               |                     | mov %eax, 0x8049a1c |       113        |         51         |        **51**         |
| **interrupt** |                     |                     |                  |                    |                       |
| T2 상태저장   |                     |                     |                  |                    |                       |
| T2 상태복원   |                     |                     |       108        |         51         |          51           |
|               | mov %eax, 0x8049a1c |                     |       113        |         51         |        **51**         |

위 처럼 명령어의 실행 순서에 따라 결과가 달라지는 상황을 **경쟁 조건(race condition)** 이라고 하고 구체적으로는 데이터 경쟁(data race) 라고 부른다.

실행할 때 마다 경과가 다른 경우를 **비결정적(indeterminate)** 인 결과라고 부른다.

경쟁 조건이 발생하는 영역의 코드를 **임계 영역(critical section)** 이라고 부른다.

이러한 코드에서 필요한 것은 **상호 배제(mutual exclusion)** 이다.

이 속성은 하나이 쓰레드가 임계 영역 내의 코드를 실행중일 때는 다른 쓰레드가 실행할 수 없도록 보장해 준다.

> **여담: 원자적 연산(atomic operation)을 사용하자**
>
> 원자적 연산들은 컴퓨터 시스템을 이루는 가장 강력한 기술 중에 하나로서 컴퓨터 구조와 우리가 지금 다루고 있는 병행 코드, 파일 시스템들과 데이터베이스 관리 시스템들 그리고 분산 시스템들의 근간을 이룬다.
>
> 연속된 동작을 **원자적** 으로 만든다는 개념은 간단하게 "전부 아니면 전무 (all or nothing)"라고 표현할 수 있다.
>
> 이 개념은 데이터베이스와 트랜잭션 처리 분야에서 심도 있게 다루고 있다.

이런 문제에 대한 명쾌한 설명을 알고 싶다면 "Cooperating Sequential Processes"라는 1968년의 논문을 읽어보길 바란다.

## 5. 원자성에 대한 바람

Critical section 문제에 대한 해결 방법 중 하나로 강력한 명령어 한 개로 의도한 동작을 수행하여, 인터럽트 발생 가능성을 원천적으로 차단하는 것이 있다.

예를 들어 다음과 같은 강력한 명령어가 있다고 해보자

```assembly
memory-add 0x8049a1c, $0x1
```

이 명령어는 메모리 상의 위치에 어떤 값을 더하는 명령어다.

하드웨어는 이 명령어가 원자적으로 실행되는 것을 보장한다고 하자.

우리는 위의 3가지 명령어가 원자적으로 실행되길 원한다.

일련의 명령어들을 단일 명령어로 대체할 수 있다면, 그 명령어를 사용하면 그만이다.

하지만 일반적인 상황에서 사용할 수 있는 그러한 명령어는 존재하지 않는다.

따라서 우리는 대신 하드웨어에 **동기화 함수(synchronization primitives)** 구현에 필요한 몇 가지 유용한 명령어를 요청해야 한다.

>  **핵심 질문: 동기화를 지원하는 방법**
>
> 유용한 동기화 함수를 만들기 위해 어떤 하드웨어 지원이 필요한가?
>
> 운영체제는 어떤 지원을 해야 하는가?
>
> 어떻게 하면 이런 함수를 정확하고 효율적으로 만들 수 있을까.
>
> 프로그램들이 이 함수들을 활용하여 의도한 결과를 얻으려면 어떻게 해야 할까?

## 6. 또 다른 문제: 상대 기다리기

실제로는 하나의 쓰레드가, 다른 쓰레드가 어떤 동작을 끝낼 때까지 대기해야 하는 상황도 빈번하다.

프로세스가 디스크 I\O를 요청하고 응답이 올 때까지 잠든 경우가 좋은 예다.

이후, 원자성 지원을 위한 동기화 함수 제작에 대한 내용과 멀티 쓰레드 프로그램에서 흔한 잠자기/깨우기 동작에 대한 지원 기법에 대해 다룬다.

**컨디션 변수(condition variable)** 에 대한 장을 읽을 때 즈음 이해가 될 것이다.

