# Scheduling

**핵심질문** : 스케줄링 정책은 어떻게 개발하는가?

---

## 1. 워크로드에 대한 가정

**워크로드** 란?

> 프로세스가 동작하는 일련의 행위

처음에는 현실과는 거리가 있는 워크로드를 가정해서 스케줄링 정책을 만들어보고(이해를 쉽게하기 위해), 점차 현실적인 워크로드를 사용하자.

처음에는 다음과 같은 가정을 한다.

1. 모든 작업은 같은 시간 동안 실행된다.
2. 모든 작업은 동시에 도착한다.
3. 작업은 일단 시작하면 최종적으로 종료될 때까지 실행된다.
4. 모든 작업은 CPU만 사용한다. (입출력을 수행하지 않는다.)
5. 각 작업의 실행 시간은 사전에 알려져 있다.

다시 말자하지만 현실적이지 않은 가정이다. 특히 미리 모든 작업 실행시간을 알 수 있다는 점이 그러하다.

---

## 2. 스케줄링의 평가 항목

어떤 스케줄링이 좋은 스케줄링인가 판단하기 위해 **스케줄링 평가 항목(scheduling metric)** 을 결정해야 한다.

다양한 평가기준이 존재한다.

- **반환 시간(turnaround time)** 

  작업이 완료된 시각에서 작업이 도착한 시각을 뺀 것이다.

  ***T*** *(turnaround)* = ***T*** *(completion)* - ***T*** *(arrival)*

  현재는 모든 작업이 동시에 도착한다고 가정했으므로, ***T*** *(arrival)* = 0 이고, ***T*** *(turnaround)* = ***T*** *(completion)* 이다.

  나중에는 가정이 현실적으로 변할것이다.

  반환 시간은 **성능** 측면에서의 평가 기준이다.

- **Jain's Fairness Index** 

  **공정성 (fairness)** 의 지표이다.

보통 성능과 공정성은 서로 상충한다. 성능을 높이려면 공정성을 포기해야 하고, 공정성을 높이려면 성능을 포기해야한다. (trade off 관계)

---

## 3. 선입선출 (FIFO)

가장 기본적인 알고리즘은 **선입선출 (First In First Out, FIFO)** a.k.a **선도착선처리 (First Come First Served, FCFS)** 이다.

예를들어, 다음과 같은 상황을 가정해 보자.

> 1. 시스템에 3개의 작업 A, B, C 가 거의 동시에 도착했다. (***T*** *(arrival)* = 0), 간발의 차이로 A, B, C 순서대로 들어왔다.
> 2.  각 작업은 10초 동안 실행된다. 

이 작업들의 **평균 반환 시간**은 얼마인가?

**A** 는 10, **B** 는 20, **C** 는 30 에 작업이 종료된다.

세 작업의 **평균 반환 시간** 은 **(10+20+30) / 3 = 20** 이다.

---

이제 위에서 가정한 조건 중 하나를 완화해보자.

이제부터는 작업시간이 같지 않다. FIFO는 이러한 조건에서도 좋은 동작을 할까?

> **A** 는 100, **B** 는 10, **C** 는 10 의 실행시간을 가진다고 가정해보자.

**평균 반환 시간** = (100+110+120) / 3 =. 110 이 된다. (상당히 결과가 나빠졌다!)

이러한 현상을 **convey effect** 라고 부른다.

> **convey effect** 는 CPU를 많이 필요로 하지 않는 프로세스들이, CPU를 오랫동안 사용하는 프로세스가 끝나기를 기다리는 현상이다.
>
> 공항에서 줄을 잘못서서 내 앞사람이 너무 오래 걸리는 것을 상상해보면 된다.

그렇다면 실행 시간이 다른 경우에는 어떤 알고리즘을 사용해야 할까?

---

## 4. 최단 작업 우선 (Shortest Job First, SJF)

간단히 해결할 수 있다. 내용도 알고리즘의 이름과 동일하다.

위와 동일한 조건에서 실행시간이 가장 짧은 것을 앞에 배치한다.

> **A** 는 100, **B** 는 10, **C** 는 10 의 실행시간을 가진다.

B, C 이후에 A를 실행한다.

**평균 반환 시간** = (10+20+120) / 3 = **50**

FIFO 의 110 보다 두배 이상 빨라졌다.

**SJF** 는 장점이 많다. 그렇다면 이제 다 해결된 것인가? **아니다!** 아직 우리는 비현실적인 가정을 하고 있다. 

이제부터 모든 작업이 동시에 도착하는 것이 아닌, 임의의 시간에 도착한다고 해보자.

> - **A** 는 **t = 0** 에 도착, **100초** 의 실행 시간.
> - **B** 는 **t = 10** 에 도착, **10초** 의 실행 시간.
> - **C** 는 **t = 10** 에 도착, **10초** 의 실행 시간.

이전의 **convey effect** 문제가 다시 발생한다!

**평균 반환 시간** = (100+(110-10)+(120-10)) / 3 =. **103.3**

그렇다면 어떻게 해야 하는가?

---

과거에는 **비선점 스케줄러 (non-preemptive scheduler)** 가 사용되었다.

- **비선점 스케줄링 (non-preemptive scheduling)**

  이 시스템은 각 작업이 종료될 때까지 기다린다. (프로세스가 알아서 넘겨줄 것이라 믿고)

- **선점 스케줄링 (preemptive scheduling)**

  이 시스템은 다른 프로세스를 실행시키기 위하여 필요하면 현재 프로세스의 실행을 중단한다.

  이론적으로 모든 현대 스케줄러는 이 방식으로 작동한다.

---

## 5. 최소 잔여시간 우선 (Shortest Time-to-Completion First, STCF)

위 문제를 해결하기 위해서는 **가정 3 (작업은 일단 시작하면 최종적으로 종료될 때까지 실행된다.)** 을 완화해야 한다.

타이머 인터럽트가 발생하고 **문맥 교환** 이 가능해지면, B나 C가 도착했을 때 A를 중단하고 다른 작업으로 스위치가 가능하다.

중단된 A는 나중에 다시 실행된다.

앞서 설명한 **SJF** 는 **비선점 스케줄링** 이기 때문에 실행중인 작업을 중지하고 다른 작업을 실행하지 못한다.

**SJF** 에 **선점 기능** 을 추가한 것이 **최단 잔여시간 우선 (Shortest Time-to-Completion First, STCF)** 이다.

> 이 스케줄러는 현재 실행중인 작업의 잔여 실행 시간과 새로운 작업의 잔여 실행 시간을 비교하여, 잔여 실행 시간이 가장 작은 작업을 스케줄한다.

**STCF** 를 이용해 스케줄을 해보면,

**평균 반환 시간** = ((120-0)+(20-10)+(30-10)) / 3 = **50** 이 되어 시간이 단축된다.

새로운 가정하에 **STCF** 가 최적의 스캐줄러이다.

## 6. 새로운 평가 기준: 응답 시간

**STCF** 는 초기의 컴퓨터에서는 의미가 있었지만 **시분할 컴퓨터** 의 등장이 이를 바꾸어버렸다.

이제 사용자는 터미널에서 작업하면서 시스템에게 상호작용을 원할히 할 성능을 요구하기 시작한다.

**응답 시간 (response time)** 이라는 새로운 평가 기준이 생겨난 것이다.

- **응답 시간 (response time)**

  작업이 도착하는 시점부터 처음으로 스케줄 될 때까지의 시간.

  ***T*** *(response)* = ***T*** *(first turn)* - ***T*** *(arrival)*

예를 들어

> - **A** 는 시간 **0** 에 도착
> - **B** 는 시간 **10** 에 도착
> - **C** 는 시간 **10** 에 도착

이라고 하면, 응답시간은

- A 의 응답시간 = 0
- B 의 응답시간 = 0
- C 의 응답시간 = 10

으로 **평균 응답 시간** 은 **3.33** 이 된다.

**STCF** 류의 정책들의 응답시간은 절대 짧다고 할 수 없다.

반환시간 기준으로는 훌륭하지만, 응답 시간과 상호작용 측면에선는 매우 나쁜 방법이다.

단순히 다른 작업이 내 작업보다 먼저 스케줄 되었다는 이유로 시스템의 응답을 10초 이상 기다린다고 생각해봐라.

그렇다면 응답 시간을 최소화 하기 위해서는 어떤 스케줄러를 만들어야 할까?

---

## 7. 라운드 로빈 (Round-Robin, RR)

응답 시간 문제를 해결하기 위해 도입되었다.

기본 발상은 간단하다. 작업이 끝날 때까지 기다리지 않는다. **일정한 시간** 동안 실행한 후 실행 큐의 다음작업으로 전환한다.

이때의 **일정한 시간** 을 **타임 슬라이스 (time slice)** 라고 한다.

이러한 이유로 **RR** 방식을 **타임 슬라이싱** 이라고 부르기도 한다.

타임 슬라이스의 길이는 타이머 인터럽트 주기의 배수이여야 한다.

다음과 같이 가정해보자.

> 1. A, B, C 는 시스템에 동시에 도착한다.
> 2. 각각 5초간 실행된다.

평균 응답시간은

- **RR** 의 경우, (0+1+2) / 3 = 1 이다.
- **SJF** 의 경우, (0+5+10) / 3 = 5 이다.

**타임 슬라이스의 길이** 는 **RR** 에 있어 매우 중요한 요소이다.

- 타임 슬라이스가 짧을 수록, 응답 시간이 빨라진다. 그러나 문맥 교환 비용이 증가한다.
- 타임 슬라이스가 길 수록, 문맥 교환 비용이 줄어든다. 그러나 응답시간이 느려진다.

이를 고려하여 적절한 수준의 타임 슬라이스 길이를 정하는 것이 중요하다.

이제 **RR** 이 **응답시간** 기준으로 훌륭한 스케줄러인 것을 알았다.

**반환 시간 기준** 으로는? 최악이다.

일반적으로 RR과 같이 공정한 정책일수록 반환 시간은 나빠진다.

우리는 여전히 두 가지의 비현실적인 가정을 하고 있다. (입출력을 하지않는다, 실행시간을 미리 알고 있다.)

이 가정들을 완화해보자.

## 8. 입출력 연산의 고려

모든 프로그램은 입출력 작업을 수행한다. 아무런 입력도 없는 프로그램은 항상 같은 결과를 내는 프로그램일 것이다.

실행중인 프로세스가 입출력 작업을 요청하면, 스케줄러는 다음에 어떤 작업을 실행할지 결정해야 한다.

입출력 작업을 하는 동안 CPU가 놀고 있게 둘 순 없다.

마찬가지로 입출력 완료 시에도 결정을 해야한다. 입출력이 완료되면 인터럽트가 발생하고, 인터럽트를 기다리던, 입출력을 요청한 프로세스가 대기 상태에서 준비 상태로 바뀐다. 이 프로세스를 다시 실행할것인가 아니면 다른 프로세스를 실행할 것인가?

대화형 작업이 입출력을 실행하는 동안 다른 계산위주의 작업들이 실행된다.

이렇게 하면 결과적으로 CPU의 이용률을 높일 수 있다.

---

## 9. 만병통치약은 없다 (No More Oracle)

과연 마지막 가정이 가능한 가정이었을까?

스케줄러는 각 작업의 실행 시간을 미리 알 수 있을까?

일반적인 운영체제는 이를 미리 알 수 있는 방법이 없다.

이렇게 어떠한 사전 지식도 없이 어떻게 **SJF/STCF** 처럼 동작하는 알고리즘을 구축할 수 있을까?

추가적으로, 응답 시간 개선을 위해, **RR** 스케줄러의 아이디어를 도입할 방법은 없을까?



