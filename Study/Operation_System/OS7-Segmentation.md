# Segmentation

**핵심 질문: 대형 주소 공간을 어떻게 지원하는가**

지금까지는 프로세스 주소 공간 전체를 탑재하는 것을 가정해 왔다.

그러나 스택과 힙 사이에 사용되지 않는 큰 공간이 발생하게 된다.

이는 큰 메모리 낭비를 의미한다.

또 주소 공간이 물리 메모리보다 큰 경우 실행이 매우 어렵다.

---

## 1. 세그멘테이션: 베이스/바운드 의 일반화

위 문제를 해결하기 위해 등장한 방법이 **세그멘테이션 (segmentation)** 이다.

- **세그멘트 (segment)** 란?

  세그먼트는 특정 길이를 가지는 연속적인 주소 공간이다.

  코드, 스택, 힙 세 종류의 세그먼트로 나누어 사용한다.

- **세그멘테이션 (segmentation)** 이란?

  MMU에 하나의 베이스와 바운드값이 존재하는 것이 아니라 **세그먼트** 마다 각각 베이스와 바운드 값이 존재한다.

  코드, 스택, 힙 세 종류의 세그멘트를 따로 다른 위치에 배치 가능하다.

- **세그멘테이션** 의 장점?

  세그멘테이션을 사용하면 각 세그먼트를 각기 다른 위치의 물리메모리에 배치할 수 있다.

  따라서 사용되지 않는 가상 주소 공간이 물리 메모리를 차지하는 것을 방지할 수 있다.

---

예를 들어보자

**가상주소**

- 코드영역: 0KB ~ 2KB
- 힙영역: 4KB ~ 7KB
- 스택영역: 14KB ~ 16KB

**물리주소**

- 운영체제: 0KB ~ 16KB
- 코드: 32KB ~ 34KB
- 스택: ~30KB (스택은 메모리의 높은 주소에서 낮은 방향으로 자란다.)
- 힙: 34KB ~ (힙은 메모리의 낮은 주소에서 높은 방향으로 자란다.)

| Segment | Base | Size |
| ------- | ---- | ---- |
| Code    | 32K  | 2K   |
| Heap    | 34K  | 2K   |
| Stack   | 28K  | 2K   |

`physical address = offset + base` 

`offset = virtual address - start address of segment` 오프셋이란?: 그 세그멘트 안에서의 상대적인 주소.

**가상주소 100번지를 참조한다고 가정하자. (100bit)**

1. 100번지는 책의 그림을 참고하면, 코드 세그멘트에 속한다.
2. 참조가 일어나면 하드웨는 베이스 값에 이 세그멘트의 오프셋(이 예시의 경우 100)을 더해 물리 주소는 `100+32KB = 100+2^15 = 32868` 이 된다.
3. 그 후 주소가 범위 내에 있는지 검사한다. (100은 2KB 보다 작다.)
4. 범위 내에 있을 경우, 물리 메모리 주소 32868을 읽는다.

**이번에는 가상주소 4200의 힙을 살펴보자.**

가상주소 4200을 힙의 베이스 34KB에 더하면 물리 주소 39016을 얻지만 이 주소는 올바른 주소가 아니다.

먼저 힙 안에서의 오프셋 값을 구해야 한다.

힙은 가상 주소 4KB(4096) 에서 시작하기 때문에 오프셋은 실제로는 `4200-4096=104` 가 맞다.

해당 주소의 실제 물리주소는 `104+34KB=34920` 이 된다.

**만약 힙의 마지막을 벗어난 (7KB 보다 밖) 주소에 접근하려고 하면 어떻게 될까?**

하드웨어가 해당 주소가 범위를 벗어낫다는 것을 감지하고 운영체제에 트랩을 발생시킨다.

운영체제는 해당 프로세스를 종료시킬 가능성이 크다.

이게 C 프로그래머가 가장 싫어하는 단어의 어원이다.

**세그멘트 폴트 (segment fault)**

---

**여담 세그멘트 폴트**

Segment Fault는 세그멘트 사용 시스템에서 불법적인 주소 접근 시 발생한다.

~~재미있게도~~ 이 용어는 세그멘트에 대한 지원이 전혀 없는 컴퓨터에서도 여전히 사용된다.

이 경우에는 코드의 원일을 알 수도 없다.

(전혀 재미없다. 세그폴트는 보기만해도 치가 떨린다.)

---

## 2. 세그멘트 종류의 파악

**하드웨어는 가상 주소가 어느 세그멘트를 참조하는지, 그리고 그 세그멘트 안에서 오프셋은 얼마인지 어떻게 알 수 있는가?**

가장 일반적인 접근법은 가상 주소의 최상위 비트 몇 개를 세그멘트 종류를 나타내는 데 사용하는 것이다.

아까의 예시에서는 총 3개의 세그멘트가 있었다.

주소 공간을 3개의 세그멘트로 나누기 위해서는 2^2=4, 최소 2개의 비트가 필요하다.

세그멘트 표시를 위해 가상 주소 14비트 중 최상위 2비트를 사용하는 경우

| 13   | 12   | 11     | 10     | 9      | 8      | 7      | 6      | 5      | 4      | 3      | 2      | 1      | 0      |
| ---- | ---- | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ |
| seg  | seg  | offset | offset | offset | offset | offset | offset | offset | offset | offset | offset | offset | offset |

이렇게 될 것이다

하드웨어는 그중 최상위 비트 (13 과 12)를 보고 세그멘트의 종류를 판단 할 수 있다.

예를들어 다음과 같은 경우

| 13   | 12   | 11   | 10   | 9    | 8    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 0    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 1    | 0    | 0    | 0    | 0    | 0    | 1    | 1    | 0    | 1    | 0    | 0    | 0    |

| Segment | bits |
| ------- | ---- |
| Code    | 00   |
| Heap    | 01   |
| -       | 10   |
| Stack   | 11   |

최상위 비트는 01 이므로 하드웨어는 주소가 힙 세그멘트라는 것을 인지하여 힙의 베이스와 바운드를 사용한다.

- **오프셋은 어떻게 구하는가?**

  하위 12비트가 세그멘트 내의 오프셋이다.

  >  0000 0110 1000, 또는, 16진수로 0x068, 10진수로 104.

하드웨어는 세그멘트 레지스터를 파악하는데 처음 2비트를 이용하고, 세그멘트 오프셋으로 다음 12비트를 사용한다.

- **오프셋의 역할?**

  - 오프셋에 베이스 레지스터 값을 더하여 하드웨어는 최종 물리 주소를 계산한다.

  - 오프셋은 바운드 검사도 쉽게 만든다.

    오프셋이 바운드보다 작은지 여부만 검사하면 된다. (바운드보다 크면? -> 주소가 잘못된 것.)

베이스와 바운드 값들을 배열로 저장할 경우 (세그멘트별로 값이 존재). 물리 주소는 다음과 같이 계산된다.

```
// 14 bit VA중의 상위 2bit를 얻어옴.
Segment = (VirtualAddress & SEG_MASK) >> SEG_SHIFT
// 이제 오프셋을 얻어옴
Offset = VirtualAddress & OFFSET_MASK
if (OFFSET >= BOUNDS[Segment]) // 바운드 넘어가면
	RaiseException(PROTECTION_FAULT)
else // 바운드 안 넘어가면
	PhysAddr = Base[Segment] + Offset
	Register = AccessMemory(PhysAddr)
```

우리가 살펴봤던 예시로 보면,

- SEG_MASK = 0x3000

- SEG_SHIFT = 12

- OFFSET_MASK = 0xFFF (00111111111111)

  마스크를 and 연산하면 offset 부분만 뽑아낼 수 있다.

---

**문제점** (참고만)

- 세개의 세그멘트(코드, 힙, 스택)가 있고, 2^2 = 4 이므로 하나의 세그멘트는 미사용으로 남는다.

  즉, 전체 주소 공간의 1/4 은 사용이 불가능하다.

- 가상 주소공간의 활용도가 제한된다.

  예를들어, 16KB 주소공간을 4개의 주각 4KB 씩으로 나누면, 최대 4KB 밖에 못쓴다는 것.

---

## 3. 스택

**스택은 아주 중요한 차이점이 있다. 스택은 다른 것들과는 반대 방향으로 확장된다. (낮은 주소 방향으로 확장)**

이러한 특징 때문에 다른 방식의 변환이 필요하다.

- 간단한 **하드웨어** 가 추가로 필요하다.
  - 베이스와 바운드 값에 더해 하드웨어는 세그멘트가 어느 방향으로 확장하는지 알아야 한다.

    예를들어, 하나의 비트를 할당해서, 높은 주소방향이면 1, 낮은 주소방향이면 0 으로 설정.

아래 그림은 **세그멘트 레지스터(반대 방향 확장 지원 기능 포함)** 을 나타낸 표이다.

| 세그멘트  | 베이스 | 크기 | 순방향으로 증가? |
| --------- | ------ | ---- | ---------------- |
| 코드 (00) | 32 KB  | 2 KB | 1                |
| 힙 (01)   | 34 KB  | 3 KB | 1                |
| 스택 (11) | 28 KB  | 2 KB | 0                |

**그렇다면 하드웨어는 이제 반대 방향 (스택) 가상 주소를 어떻게 변환하는가?**

1. 가상 주소 15KB 에 접근하려한다. (이 주소는 물리 주소 27KB 에 매핑되어야 한다.)

2. 이 가상 주소를 이진 형태로 바꾸면 11 1100 0000 0000 이다. (0x3C00)

3. 하드웨어는 상위 2비트 (11)를 사용하여 세그멘트를 지정한다.

   이를 고려하면 3KB의 오프셋이 남는다.

4. 올바른 음수 오프셋을 얻기 위해서 3KB 에서 세그멘트 최대 크기를 뺀다.

   여기서는, 세그멘트 최대 크기가 4KB 이고,

   올바른 오프셋은 3KB - 4KB = -1KB 이다.

5. 이 음수 오프셋 (-1KB)을 베이스(28KB)에 더하면 올바른 물리 주소 27KB를 얻게 된다.

6. 이 음수 오프셋의 절대값(1KB)가 세그멘트의 현재 크기(2KB) 보다 작거나 같다는 것을 확인하여 바운드 검사를 할 수 있다.

---

## 4. 공유 지원

**개발자들은 메모리를 절약하기 위해 떄로는 주소 공간들 간에 특정 메모리 세그멘트를 공유하는 것이 유용하다는 것을 알게 되었다.**

- 세그멘트는 주소 공간들 간에 공유될 수 있다.

  - **코드 공유 (code sharing)** 가 일반적이다. (현대의 시스템에까지 사용된다.)
  - 하드웨어의 지원이 필요하다.

- **Protection bit** 이 하드웨어에 추가되어야 한다.

  - 세그멘트 마다 protection bit 를 추가하여, 세그멘트를 읽거나 쓸 수 있는지, 세그멘트의 코드를 실행시킬 수 있는지 나타낸다.

    코드 세그멘트를 읽기 전용으로 설정하면 주소 공간의 독립성을 유지하면서도, 여러 프로세스가 주소 공간의 일부를 공유할 수 있다.

    각 프로세스는 여전히 자신의 전용 메모리를 사용하고 있다고 생각하지만 운영체제는 변경이 불가능하도록 공유시켜 환상을 유지한다.

**다음은 세그멘트 레지스터 값(보호 정보 포함)** 의 그림이다.

| 세그멘트  | 베이스 | 크기 | 순방향으로 증가? | 보호                     |
| --------- | ------ | ---- | ---------------- | ------------------------ |
| 코드 (00) | 32 KB  | 2 KB | 1                | Read-Execute (읽기-실행) |
| 힙 (01)   | 34 KB  | 3 KB | 1                | Read-Write (읽기-쓰기)   |
| 스택 (11) | 28 KB  | 2 KB | 0                | Read-Write (읽기-쓰기)   |

---

## 5. 소단위 VS 대단위 세그멘테이션 (Fine-Grained and Coarse-Grained)

**세그멘트 잘게 나누기 VS 세그멘트 크게 나누기**

- **Coarse-Grained:** 우리가 봤던 예시들이 여기 해당한다.

  예) 코드, 힙, 스택 으로 나눈 것.

- **Fine-Grained:** 일부 초기 시스템이 지원했다.

  **세그멘트 테이블 (segment table)** 같은 하드웨어의 지원이 필요하다.

  당시에는 이렇게 잘게 나누는것이 효율적이라 생각했다.

---

## 6. 운영체제의 지원

세그멘테이션을 도입하기 위해서는 운영체제가 몇가지 문제를 해결해 주어야 한다.

1. 문맥교환
2. 세그멘트 크기의 변경
3. 미사용 중인 물리 메모리 공간의 관리 (가장 중요한 문제)

가장 중요한 3번문제를 **외부 단편화 (external fragmentation)** 이라고 부른다.

- **External Fragmentation:** 중간중간 애매하게 작은 크기의 구멍들이 생긴다. 이때문에 새로운 세그멘트를 할당하기 어려워진다.

  - 24KB의 free 메모리가 있다고 해도, 만약 이것들이 하나의 연속된 세그멘트가 아니라 잘게 잘린 조각들이라면?

    OS는 20KB 정도의 request를 수행 할 수 없다.

이 문제의 해결책 중 한가지는 기존의 세그멘트를 정리하여 물리 메모리를 **압축(compact)** 하는 것이다.

- **Compaction: ** 물리 메모리에 존재하는 세그멘트들을 재정렬한다.

  실제로 오버헤드가 매우 크기 때문에 사용하지 않는 방법이다.

  1. 프로세스를 멈춘다.
  2. 데이터를 어딘가로 복사한다.
  3. 세그멘트 레지스터 값을 바꾼다.

---

## 7. 요약

### 세그멘테이션 장점

- 서로 떨어뜨려서 주소공간 배정이 가능하다.
  - 스택과 힙이 독립적으로 자랄 수 있게 할 수 있다.
  - **내부 단편화 (internal fragmentation)** 이 없다.
- 빠르고, 쉽고, 변환 오버헤드가 작다. (하드웨어 구현에 잘 맞기 때문에)
- 세그멘트 공유가 쉽다.
- 각각의 세그멘트의 동적 재배치를 지원한다.

---

### 세그멘테이션 단점

- **외부 단편화**

  해결을 위해서는 각각의 세그멘트가 연속적으로 배치되어야 한다. (compaction, 압축)

  큰 세그멘트를 이용하기에는 물리 메모리가 커야한다.

- 세그멘테이션이 유연하지 않다.

  만약 가끔 사용되는 힙 세그멘트의 크기가 크다고 생각해보자.

  이 힙에 접근하려면 이 커다란 힙 세그멘트 전체가 물리 메모리에 올라가 있어야 한다.

---

### 이를 해결하기위해...

만약 가변적인 크기의 덩어리로 메모리를 잘라 쓰는 것이 아니라,

**고정 크기** 로 잘라서 쓴다면? -> **Paging**

이 방법을 페이징이라고 한다.