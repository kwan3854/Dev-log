# Transport Layer - GBN & Selective Repeat

여태까지 시도한 방법은 잘 동작하지만 엄청 느리다. 즉, 성능이 구리다.

### 가정

- 1 Gbps link
- 15 ms prop delay (한 패킷 가는데)
- 8000 bit packet 을 보내야 한다면 (8000bit = 1KB)

### 생각

- `D(trans) = L/R = 8000/10^9 = 8 microsecs`

- sender 의 utilization(활동도) 은?

  `U(sender) = (L/R) / (RTT + L/R) = 0.008/30.008 = 0.00027`

  즉, 대부분의 시간을 놀고 있다는 것이다.

- 너무 많은 대역폭을 낭비한다

  - RTT = 15+15 = 30msec (Round Trip Time, 왕복 시간)

  - 1KB 크기의 패킷을 매 30 msec 마다 보냄

    33kB/sec = 264kbit/sec

    무려 1Gbps link 에서 (1000kbit/sec)

### 결론

우리가 고안한 네트워크 프로토콜이 physical resources 를 제한하고 있다.

우리의 네트워크 프로토콜이 bottle neck 인 상태이다.

## 1. 기존의 방법: Stop and Wait operation

1. 첫번째 패킷이 전송 시작된다.
2. L/R 시간이 걸려서 패킷이 transmit 된다.
3. RTT/2 시간이 걸려서 receiver 에게 패킷이 도착한다.
4. receiver 가 응답한다. (ACK 을 보낸다)
5. RTT/2 시간이 걸려서 sender 에게 도착한다.
6. 다음 패킷을 보낸다.
7. 총 t = RTT + L/R 시간이 걸렸다.

`U(sender) = (L/R) / (RTT + L/R) = 0.008/30.008 = 0.00027`

## 2. 새로운 방법: Pipelined protocols

### Pipelining 이란?

sender 가 여러개의 패킷을 동시에 보낼 수 있게 한다.

즉, 내가 보낸 패킷이 전선을 따라 날아가고 있는 중에 (도착하기 전에) 다음 패킷을 또 보낼 수 있다는 뜻이다.

자동차 공장에서 하나의 자동차를 만들기 시작해서, 그 자동차가 완성되기 전에,

다음 자동차의 일부를 만들기 시작, 계속 컨베이어 벨트를 따라 자동차가 이동하는 것을 생각하면 된다.

### 고려해야 할 점

- sequence number 의 숫자가, 원래는 0과 1만 있으면 됐었지만,

  이제는 더 많은 숫자가 필요할 것임을 예측할 수 있다.

- sender 쪽, 그리고 receiver 쪽에 패킷을 담아 둘 버퍼가 필요할 것이다.

### Pipelined protocol 의 종류

- go-Back-N
- selective repeat

위 두가지는 전송이 잘못되어서, 재전송을 할 때

패킷을 어떻게 재전송해 줄지, 그 방법에 따라 구분된다.

### 얼마나 utilization 이 좋아질까?

만약 패킷 3개를 동시에 보낸다면?

`U(sender) = 3(L/R) / (RTT + L/R) = 0.024/30.008 = 0.00081`

3개를 동시에 보냈더니, 3배로 활용도가 좋아졌다.

## 3. 두 개의 pipelined protocol 간단 비교

### Go-back-N

- sender 가 N 개의 패킷을 동시에 보낼 수 있다.

  (ACK 을 안받고도, pipeline 에 동시에 N개의 패킷을 보낼 수 있다)

- receiver 는 **오직 cumulative ack 만 보내면 된다.**

  >  cumulative ack?
  >
  > 패킷 하나 하나 ACK 보내줄 필요 없이
  >
  > 받은 패킷 그룹의 마지막만 ACK 을 보내준다.
  >
  > 예를 들어 1~8 여덟개의 패킷을 한번에 받는다고 해보자.
  >
  > 1,2,3 까지 잘 받고, 4실패, 5,6,7,8 을 다시 잘 받았다면?
  >
  > 3에대한 ACK 을 보내준다.

- **sender 는 ack 을 받지 않은 패킷 중 가장 오래된 패킷의 타이머를 가지고 있다.**

  만약 타이머가 다 되면?

  모든 unacked 패킷을 다시 보낸다.

### Selective Repeat

- sender 가 N 개의 패킷을 동시에 보낼 수 있다.(go back N 과 동일)

- **receiver 는 각각의 패킷에 대해 ack을 각각 보내준다.**

- **sender 는 각각의 모든 unacked 패킷에 대한 타이머를 가지고 있다.**

  만약 타이머가 다 되면?

  타이머가 다 된 그 unacked 패킷만 다시 보낸다.

## 4. Go-Back-N 에 대해 자세히

### Sender

- 패킷의 header 에는 k-bit 의 sequence number 가 있다.

  `0` ~ `2^k - 1` 의 sequence number 표기가 가능할 것이다.

- window 라는 것이 있다.

  최대 N 개의 연속적인 unacked 패킷을 허용할 수 있는 추상적인 바운더리

  window 의 크기가 곧 N, 한번에 보낼 수 있는 패킷의 양을 의미하게 된다.

- 버퍼 내부를 다음 네가지로 분류해서 생각하자

  1. 이미 ack 을 받은 패킷
  2. 보냈지만 아직 ack 은 받지 못한 패킷
  3. usable, not yet sent 패킷
  4. not usable 한 패킷

- 날려보낸 패킷 중 가장 오래된 패킷 기준으로 타이머를 돌린다. (당연히 Ack 받은것은 제외)

- 만약 n 번 패킷이 타임아웃되면? timeout(n)

  n번 패킷과 window 안에 있는 n 번보다 번호 큰 패킷들 전부 다시 보내야 한다.

  그 뒤는 잘갔다는 보장이 없기 때문. (cumulative ack)

### Receiver

- 이것만 Ack 하면 된다!

  각각의 패킷을 모두 잘 받았다고 Ack 해주지 않는다.

  잘 받은 패킷들 중 마지막 패킷의 번호만 ack 해주면 된다.

  - 중복되는 ack 을 보낼 수도 있다.

  - 내부 동작할때 내가 받기를 기대하는 번호만 기억하고 있으면 된다.

    **expectedseqnum**

- 순서에 맞지 않는 패킷이 온다면?

  - discard, 즉 버린다. receiver 측은 저장할 버퍼가 없다.
  - 잘 받은 패킷의 연속 중, 마지막 패킷 번호를 ack 해 준다.

### 장점

- 단순함
- receiver 쪽에 버퍼가 필요없다.

### 단점

- 비효율적이다.

  딱 하나 잘못되었어도, 뒤에 잘 받은 패킷들 전부다 버리고 새로 받아야 한다.

  > 내 사견을 더하자면,
  >
  > 아마 N 의 값이 커질 수록 비효율성이 커질것이다.
  >
  > 마치 반도체 공정에서 다이 사이즈가 커질수록, 수율이 떨어지는 것을 생각하면 된다.

## 5. Selective repeat 에 대해 자세히

### Go Back N 에 비해 다른점

- sender 에서 timer 가 packet 마다 유지되어야 한다.

  (go back N 은 가장 오래된 것만 timer 돌리면 되었다.)

- Receiver 쪽에도 버퍼가 필요하다.

### 왜 receiver 쪽에도 버퍼가 필요한가?

만약 7개의 패킷을 동시에 받는다고 생각해보자. (윈도우 사이즈가 7인 경우)

기존에는 잘 받으면 바로바로 app layer 쪽으로 올려주고,

잘못되면 바로 다 버렸다.

그런데, 이번에는 잘 받은것은 버리기 아까우니, 보관해두고 싶은 것이다.

그런데, **app layer 는 transport layer 쪽에서 순서대로 잘 보내줄것이라 믿고있다.**

그래서 잘 받은 것들을 보관하고 있다가, 잘못된것도 받아서 순서 맞춰서 하나씩 app쪽에 올려줘야 한다.

이를 위해서 버퍼가 필요한 것이다.

아래의 표는 receiver 쪽의 버퍼를 표현한 것이다.

| 0        | 1        | 2        | 3                          | 4               | 5               | 6               |
| -------- | -------- | -------- | -------------------------- | --------------- | --------------- | --------------- |
| OK(올림) | OK(올림) | OK(올림) | X(다시 받기를 기다리는 중) | OK(버퍼에 저장) | OK(버퍼에 저장) | OK(버퍼에 저장) |

앞의 0,1,2 는 잘 왔다.

그래서 순서대로 app layer 쪽으로 올렸다.

그런데 3번 패킷 하나가 깨져서 왔다.

4,5,6 은 잘 와서 보관중이다. 3번을 아직 가지고 있지 않아서 위로 올려주지 못하고 보관만 한다.

3번을 다시 받고나면, 3번부터 다시 app layer 에 올려준다.

0번이 깨질 경우(worst case)까지 고려해서 N 크기의 버퍼가 필요하다.

### 참고: 다시 패킷을 받는 방법 (Nak 은 필요없다)

참고로, receiver 가 깨진 패킷을 받아서 패킷을 다시 받고 싶을때 Nak 을 보낼 것이라 생각하기 쉽다.

그러나 Nak 을 보내지 않는다. (보낼 필요가 없다.)

sender는 각각의 패킷에대해 타이머를 돌리고 있었다.

sender 는 Ack 을 받지못해 타임 아웃이 되면 자동으로 그 패킷을 다시 보내줄 것이다.

### 몇개의 sequence number 가 필요할까?

결론만 이야기 하면 적어도 2N 개, 즉, 윈도 사이즈의 2배는 필요하다.

하지만 윈도우 사이즈 N 은 수시로 변한다.

그래서 sequence number 는 여유있게 충분히 주고 사용한다.

(TCP 헤어의 k bit)

---

